/* automatically generated by rust-bindgen 0.68.1 */
#![allow(dead_code, unused_variables)]

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __BITS_PER_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const ETH_ALEN: u32 = 6;
pub const ETH_TLEN: u32 = 2;
pub const ETH_HLEN: u32 = 14;
pub const ETH_ZLEN: u32 = 60;
pub const ETH_DATA_LEN: u32 = 1500;
pub const ETH_FRAME_LEN: u32 = 1514;
pub const ETH_FCS_LEN: u32 = 4;
pub const ETH_MIN_MTU: u32 = 68;
pub const ETH_MAX_MTU: u32 = 65535;
pub const ETH_P_LOOP: u32 = 96;
pub const ETH_P_PUP: u32 = 512;
pub const ETH_P_PUPAT: u32 = 513;
pub const ETH_P_TSN: u32 = 8944;
pub const ETH_P_ERSPAN2: u32 = 8939;
pub const ETH_P_IP: u32 = 2048;
pub const ETH_P_X25: u32 = 2053;
pub const ETH_P_ARP: u32 = 2054;
pub const ETH_P_BPQ: u32 = 2303;
pub const ETH_P_IEEEPUP: u32 = 2560;
pub const ETH_P_IEEEPUPAT: u32 = 2561;
pub const ETH_P_BATMAN: u32 = 17157;
pub const ETH_P_DEC: u32 = 24576;
pub const ETH_P_DNA_DL: u32 = 24577;
pub const ETH_P_DNA_RC: u32 = 24578;
pub const ETH_P_DNA_RT: u32 = 24579;
pub const ETH_P_LAT: u32 = 24580;
pub const ETH_P_DIAG: u32 = 24581;
pub const ETH_P_CUST: u32 = 24582;
pub const ETH_P_SCA: u32 = 24583;
pub const ETH_P_TEB: u32 = 25944;
pub const ETH_P_RARP: u32 = 32821;
pub const ETH_P_ATALK: u32 = 32923;
pub const ETH_P_AARP: u32 = 33011;
pub const ETH_P_8021Q: u32 = 33024;
pub const ETH_P_ERSPAN: u32 = 35006;
pub const ETH_P_IPX: u32 = 33079;
pub const ETH_P_IPV6: u32 = 34525;
pub const ETH_P_PAUSE: u32 = 34824;
pub const ETH_P_SLOW: u32 = 34825;
pub const ETH_P_WCCP: u32 = 34878;
pub const ETH_P_MPLS_UC: u32 = 34887;
pub const ETH_P_MPLS_MC: u32 = 34888;
pub const ETH_P_ATMMPOA: u32 = 34892;
pub const ETH_P_PPP_DISC: u32 = 34915;
pub const ETH_P_PPP_SES: u32 = 34916;
pub const ETH_P_LINK_CTL: u32 = 34924;
pub const ETH_P_ATMFATE: u32 = 34948;
pub const ETH_P_PAE: u32 = 34958;
pub const ETH_P_AOE: u32 = 34978;
pub const ETH_P_8021AD: u32 = 34984;
pub const ETH_P_802_EX1: u32 = 34997;
pub const ETH_P_PREAUTH: u32 = 35015;
pub const ETH_P_TIPC: u32 = 35018;
pub const ETH_P_LLDP: u32 = 35020;
pub const ETH_P_MRP: u32 = 35043;
pub const ETH_P_MACSEC: u32 = 35045;
pub const ETH_P_8021AH: u32 = 35047;
pub const ETH_P_MVRP: u32 = 35061;
pub const ETH_P_1588: u32 = 35063;
pub const ETH_P_NCSI: u32 = 35064;
pub const ETH_P_PRP: u32 = 35067;
pub const ETH_P_CFM: u32 = 35074;
pub const ETH_P_FCOE: u32 = 35078;
pub const ETH_P_IBOE: u32 = 35093;
pub const ETH_P_TDLS: u32 = 35085;
pub const ETH_P_FIP: u32 = 35092;
pub const ETH_P_80221: u32 = 35095;
pub const ETH_P_HSR: u32 = 35119;
pub const ETH_P_NSH: u32 = 35151;
pub const ETH_P_LOOPBACK: u32 = 36864;
pub const ETH_P_QINQ1: u32 = 37120;
pub const ETH_P_QINQ2: u32 = 37376;
pub const ETH_P_QINQ3: u32 = 37632;
pub const ETH_P_EDSA: u32 = 56026;
pub const ETH_P_DSA_8021Q: u32 = 56027;
pub const ETH_P_IFE: u32 = 60734;
pub const ETH_P_AF_IUCV: u32 = 64507;
pub const ETH_P_802_3_MIN: u32 = 1536;
pub const ETH_P_802_3: u32 = 1;
pub const ETH_P_AX25: u32 = 2;
pub const ETH_P_ALL: u32 = 3;
pub const ETH_P_802_2: u32 = 4;
pub const ETH_P_SNAP: u32 = 5;
pub const ETH_P_DDCMP: u32 = 6;
pub const ETH_P_WAN_PPP: u32 = 7;
pub const ETH_P_PPP_MP: u32 = 8;
pub const ETH_P_LOCALTALK: u32 = 9;
pub const ETH_P_CAN: u32 = 12;
pub const ETH_P_CANFD: u32 = 13;
pub const ETH_P_PPPTALK: u32 = 16;
pub const ETH_P_TR_802_2: u32 = 17;
pub const ETH_P_MOBITEX: u32 = 21;
pub const ETH_P_CONTROL: u32 = 22;
pub const ETH_P_IRDA: u32 = 23;
pub const ETH_P_ECONET: u32 = 24;
pub const ETH_P_HDLC: u32 = 25;
pub const ETH_P_ARCNET: u32 = 26;
pub const ETH_P_DSA: u32 = 27;
pub const ETH_P_TRAILER: u32 = 28;
pub const ETH_P_PHONET: u32 = 245;
pub const ETH_P_IEEE802154: u32 = 246;
pub const ETH_P_CAIF: u32 = 247;
pub const ETH_P_XDSA: u32 = 248;
pub const ETH_P_MAP: u32 = 249;
pub const __UAPI_DEF_ETHHDR: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 28;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const ETH_MDIO_SUPPORTS_C22: u32 = 1;
pub const ETH_MDIO_SUPPORTS_C45: u32 = 2;
pub const ETHTOOL_FWVERS_LEN: u32 = 32;
pub const ETHTOOL_BUSINFO_LEN: u32 = 32;
pub const ETHTOOL_EROMVERS_LEN: u32 = 32;
pub const SOPASS_MAX: u32 = 6;
pub const PFC_STORM_PREVENTION_AUTO: u32 = 65535;
pub const PFC_STORM_PREVENTION_DISABLE: u32 = 0;
pub const DOWNSHIFT_DEV_DEFAULT_COUNT: u32 = 255;
pub const DOWNSHIFT_DEV_DISABLE: u32 = 0;
pub const ETHTOOL_PHY_FAST_LINK_DOWN_ON: u32 = 0;
pub const ETHTOOL_PHY_FAST_LINK_DOWN_OFF: u32 = 255;
pub const ETHTOOL_PHY_EDPD_DFLT_TX_MSECS: u32 = 65535;
pub const ETHTOOL_PHY_EDPD_NO_TX: u32 = 65534;
pub const ETHTOOL_PHY_EDPD_DISABLE: u32 = 0;
pub const ETH_GSTRING_LEN: u32 = 32;
pub const ETH_RX_NFC_IP4: u32 = 1;
pub const ETHTOOL_RX_FLOW_SPEC_RING: u32 = 4294967295;
pub const ETHTOOL_RX_FLOW_SPEC_RING_VF: u64 = 1095216660480;
pub const ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF: u32 = 32;
pub const ETH_RXFH_CONTEXT_ALLOC: u32 = 4294967295;
pub const ETH_RXFH_INDIR_NO_CHANGE: u32 = 4294967295;
pub const ETHTOOL_RXNTUPLE_ACTION_DROP: i32 = -1;
pub const ETHTOOL_RXNTUPLE_ACTION_CLEAR: i32 = -2;
pub const ETHTOOL_FLASH_MAX_FILENAME: u32 = 128;
pub const ETH_FW_DUMP_DISABLE: u32 = 0;
pub const MAX_NUM_QUEUE: u32 = 4096;
pub const ETHTOOL_GSET: u32 = 1;
pub const ETHTOOL_SSET: u32 = 2;
pub const ETHTOOL_GDRVINFO: u32 = 3;
pub const ETHTOOL_GREGS: u32 = 4;
pub const ETHTOOL_GWOL: u32 = 5;
pub const ETHTOOL_SWOL: u32 = 6;
pub const ETHTOOL_GMSGLVL: u32 = 7;
pub const ETHTOOL_SMSGLVL: u32 = 8;
pub const ETHTOOL_NWAY_RST: u32 = 9;
pub const ETHTOOL_GLINK: u32 = 10;
pub const ETHTOOL_GEEPROM: u32 = 11;
pub const ETHTOOL_SEEPROM: u32 = 12;
pub const ETHTOOL_GCOALESCE: u32 = 14;
pub const ETHTOOL_SCOALESCE: u32 = 15;
pub const ETHTOOL_GRINGPARAM: u32 = 16;
pub const ETHTOOL_SRINGPARAM: u32 = 17;
pub const ETHTOOL_GPAUSEPARAM: u32 = 18;
pub const ETHTOOL_SPAUSEPARAM: u32 = 19;
pub const ETHTOOL_GRXCSUM: u32 = 20;
pub const ETHTOOL_SRXCSUM: u32 = 21;
pub const ETHTOOL_GTXCSUM: u32 = 22;
pub const ETHTOOL_STXCSUM: u32 = 23;
pub const ETHTOOL_GSG: u32 = 24;
pub const ETHTOOL_SSG: u32 = 25;
pub const ETHTOOL_TEST: u32 = 26;
pub const ETHTOOL_GSTRINGS: u32 = 27;
pub const ETHTOOL_PHYS_ID: u32 = 28;
pub const ETHTOOL_GSTATS: u32 = 29;
pub const ETHTOOL_GTSO: u32 = 30;
pub const ETHTOOL_STSO: u32 = 31;
pub const ETHTOOL_GPERMADDR: u32 = 32;
pub const ETHTOOL_GUFO: u32 = 33;
pub const ETHTOOL_SUFO: u32 = 34;
pub const ETHTOOL_GGSO: u32 = 35;
pub const ETHTOOL_SGSO: u32 = 36;
pub const ETHTOOL_GFLAGS: u32 = 37;
pub const ETHTOOL_SFLAGS: u32 = 38;
pub const ETHTOOL_GPFLAGS: u32 = 39;
pub const ETHTOOL_SPFLAGS: u32 = 40;
pub const ETHTOOL_GRXFH: u32 = 41;
pub const ETHTOOL_SRXFH: u32 = 42;
pub const ETHTOOL_GGRO: u32 = 43;
pub const ETHTOOL_SGRO: u32 = 44;
pub const ETHTOOL_GRXRINGS: u32 = 45;
pub const ETHTOOL_GRXCLSRLCNT: u32 = 46;
pub const ETHTOOL_GRXCLSRULE: u32 = 47;
pub const ETHTOOL_GRXCLSRLALL: u32 = 48;
pub const ETHTOOL_SRXCLSRLDEL: u32 = 49;
pub const ETHTOOL_SRXCLSRLINS: u32 = 50;
pub const ETHTOOL_FLASHDEV: u32 = 51;
pub const ETHTOOL_RESET: u32 = 52;
pub const ETHTOOL_SRXNTUPLE: u32 = 53;
pub const ETHTOOL_GRXNTUPLE: u32 = 54;
pub const ETHTOOL_GSSET_INFO: u32 = 55;
pub const ETHTOOL_GRXFHINDIR: u32 = 56;
pub const ETHTOOL_SRXFHINDIR: u32 = 57;
pub const ETHTOOL_GFEATURES: u32 = 58;
pub const ETHTOOL_SFEATURES: u32 = 59;
pub const ETHTOOL_GCHANNELS: u32 = 60;
pub const ETHTOOL_SCHANNELS: u32 = 61;
pub const ETHTOOL_SET_DUMP: u32 = 62;
pub const ETHTOOL_GET_DUMP_FLAG: u32 = 63;
pub const ETHTOOL_GET_DUMP_DATA: u32 = 64;
pub const ETHTOOL_GET_TS_INFO: u32 = 65;
pub const ETHTOOL_GMODULEINFO: u32 = 66;
pub const ETHTOOL_GMODULEEEPROM: u32 = 67;
pub const ETHTOOL_GEEE: u32 = 68;
pub const ETHTOOL_SEEE: u32 = 69;
pub const ETHTOOL_GRSSH: u32 = 70;
pub const ETHTOOL_SRSSH: u32 = 71;
pub const ETHTOOL_GTUNABLE: u32 = 72;
pub const ETHTOOL_STUNABLE: u32 = 73;
pub const ETHTOOL_GPHYSTATS: u32 = 74;
pub const ETHTOOL_PERQUEUE: u32 = 75;
pub const ETHTOOL_GLINKSETTINGS: u32 = 76;
pub const ETHTOOL_SLINKSETTINGS: u32 = 77;
pub const ETHTOOL_PHY_GTUNABLE: u32 = 78;
pub const ETHTOOL_PHY_STUNABLE: u32 = 79;
pub const ETHTOOL_GFECPARAM: u32 = 80;
pub const ETHTOOL_SFECPARAM: u32 = 81;
pub const SPARC_ETH_GSET: u32 = 1;
pub const SPARC_ETH_SSET: u32 = 2;
pub const SPEED_10: u32 = 10;
pub const SPEED_100: u32 = 100;
pub const SPEED_1000: u32 = 1000;
pub const SPEED_2500: u32 = 2500;
pub const SPEED_5000: u32 = 5000;
pub const SPEED_10000: u32 = 10000;
pub const SPEED_14000: u32 = 14000;
pub const SPEED_20000: u32 = 20000;
pub const SPEED_25000: u32 = 25000;
pub const SPEED_40000: u32 = 40000;
pub const SPEED_50000: u32 = 50000;
pub const SPEED_56000: u32 = 56000;
pub const SPEED_100000: u32 = 100000;
pub const SPEED_200000: u32 = 200000;
pub const SPEED_400000: u32 = 400000;
pub const SPEED_800000: u32 = 800000;
pub const SPEED_UNKNOWN: i32 = -1;
pub const DUPLEX_HALF: u32 = 0;
pub const DUPLEX_FULL: u32 = 1;
pub const DUPLEX_UNKNOWN: u32 = 255;
pub const MASTER_SLAVE_CFG_UNSUPPORTED: u32 = 0;
pub const MASTER_SLAVE_CFG_UNKNOWN: u32 = 1;
pub const MASTER_SLAVE_CFG_MASTER_PREFERRED: u32 = 2;
pub const MASTER_SLAVE_CFG_SLAVE_PREFERRED: u32 = 3;
pub const MASTER_SLAVE_CFG_MASTER_FORCE: u32 = 4;
pub const MASTER_SLAVE_CFG_SLAVE_FORCE: u32 = 5;
pub const MASTER_SLAVE_STATE_UNSUPPORTED: u32 = 0;
pub const MASTER_SLAVE_STATE_UNKNOWN: u32 = 1;
pub const MASTER_SLAVE_STATE_MASTER: u32 = 2;
pub const MASTER_SLAVE_STATE_SLAVE: u32 = 3;
pub const MASTER_SLAVE_STATE_ERR: u32 = 4;
pub const RATE_MATCH_NONE: u32 = 0;
pub const RATE_MATCH_PAUSE: u32 = 1;
pub const RATE_MATCH_CRS: u32 = 2;
pub const RATE_MATCH_OPEN_LOOP: u32 = 3;
pub const PORT_TP: u32 = 0;
pub const PORT_AUI: u32 = 1;
pub const PORT_MII: u32 = 2;
pub const PORT_FIBRE: u32 = 3;
pub const PORT_BNC: u32 = 4;
pub const PORT_DA: u32 = 5;
pub const PORT_NONE: u32 = 239;
pub const PORT_OTHER: u32 = 255;
pub const XCVR_INTERNAL: u32 = 0;
pub const XCVR_EXTERNAL: u32 = 1;
pub const XCVR_DUMMY1: u32 = 2;
pub const XCVR_DUMMY2: u32 = 3;
pub const XCVR_DUMMY3: u32 = 4;
pub const AUTONEG_DISABLE: u32 = 0;
pub const AUTONEG_ENABLE: u32 = 1;
pub const ETH_TP_MDI_INVALID: u32 = 0;
pub const ETH_TP_MDI: u32 = 1;
pub const ETH_TP_MDI_X: u32 = 2;
pub const ETH_TP_MDI_AUTO: u32 = 3;
pub const WAKE_PHY: u32 = 1;
pub const WAKE_UCAST: u32 = 2;
pub const WAKE_MCAST: u32 = 4;
pub const WAKE_BCAST: u32 = 8;
pub const WAKE_ARP: u32 = 16;
pub const WAKE_MAGIC: u32 = 32;
pub const WAKE_MAGICSECURE: u32 = 64;
pub const WAKE_FILTER: u32 = 128;
pub const WOL_MODE_COUNT: u32 = 8;
pub const TCP_V4_FLOW: u32 = 1;
pub const UDP_V4_FLOW: u32 = 2;
pub const SCTP_V4_FLOW: u32 = 3;
pub const AH_ESP_V4_FLOW: u32 = 4;
pub const TCP_V6_FLOW: u32 = 5;
pub const UDP_V6_FLOW: u32 = 6;
pub const SCTP_V6_FLOW: u32 = 7;
pub const AH_ESP_V6_FLOW: u32 = 8;
pub const AH_V4_FLOW: u32 = 9;
pub const ESP_V4_FLOW: u32 = 10;
pub const AH_V6_FLOW: u32 = 11;
pub const ESP_V6_FLOW: u32 = 12;
pub const IPV4_USER_FLOW: u32 = 13;
pub const IP_USER_FLOW: u32 = 13;
pub const IPV6_USER_FLOW: u32 = 14;
pub const IPV4_FLOW: u32 = 16;
pub const IPV6_FLOW: u32 = 17;
pub const ETHER_FLOW: u32 = 18;
pub const FLOW_EXT: u32 = 2147483648;
pub const FLOW_MAC_EXT: u32 = 1073741824;
pub const FLOW_RSS: u32 = 536870912;
pub const RXH_L2DA: u32 = 2;
pub const RXH_VLAN: u32 = 4;
pub const RXH_L3_PROTO: u32 = 8;
pub const RXH_IP_SRC: u32 = 16;
pub const RXH_IP_DST: u32 = 32;
pub const RXH_L4_B_0_1: u32 = 64;
pub const RXH_L4_B_2_3: u32 = 128;
pub const RXH_DISCARD: u32 = 2147483648;
pub const RX_CLS_FLOW_DISC: i32 = -1;
pub const RX_CLS_FLOW_WAKE: i32 = -2;
pub const RX_CLS_LOC_SPECIAL: u32 = 2147483648;
pub const RX_CLS_LOC_ANY: u32 = 4294967295;
pub const RX_CLS_LOC_FIRST: u32 = 4294967294;
pub const RX_CLS_LOC_LAST: u32 = 4294967293;
pub const ETH_MODULE_SFF_8079: u32 = 1;
pub const ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const ETH_MODULE_SFF_8472: u32 = 2;
pub const ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const ETH_MODULE_SFF_8636: u32 = 3;
pub const ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const ETH_MODULE_SFF_8436: u32 = 4;
pub const ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const ETH_MODULE_SFF_8636_MAX_LEN: u32 = 640;
pub const ETH_MODULE_SFF_8436_MAX_LEN: u32 = 640;
pub const ETH_RESET_SHARED_SHIFT: u32 = 16;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ethhdr {
    pub h_dest: [::std::os::raw::c_uchar; 6usize],
    pub h_source: [::std::os::raw::c_uchar; 6usize],
    pub h_proto: __be16,
}
#[test]
fn bindgen_test_layout_ethhdr() {
    const UNINIT: ::std::mem::MaybeUninit<ethhdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethhdr>(),
        14usize,
        concat!("Size of: ", stringify!(ethhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ethhdr>(),
        1usize,
        concat!("Alignment of ", stringify!(ethhdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_dest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethhdr),
            "::",
            stringify!(h_dest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_source) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ethhdr),
            "::",
            stringify!(h_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_proto) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethhdr),
            "::",
            stringify!(h_proto)
        )
    );
}
#[doc = " struct ethtool_cmd - DEPRECATED, link control and status\n This structure is DEPRECATED, please use struct ethtool_link_settings.\n @cmd: Command number = %ETHTOOL_GSET or %ETHTOOL_SSET\n @supported: Bitmask of %SUPPORTED_* flags for the link modes,\n\tphysical connectors and other link features for which the\n\tinterface supports autonegotiation or auto-detection.\n\tRead-only.\n @advertising: Bitmask of %ADVERTISED_* flags for the link modes,\n\tphysical connectors and other link features that are\n\tadvertised through autonegotiation or enabled for\n\tauto-detection.\n @speed: Low bits of the speed, 1Mb units, 0 to INT_MAX or SPEED_UNKNOWN\n @duplex: Duplex mode; one of %DUPLEX_*\n @port: Physical connector type; one of %PORT_*\n @phy_address: MDIO address of PHY (transceiver); 0 or 255 if not\n\tapplicable.  For clause 45 PHYs this is the PRTAD.\n @transceiver: Historically used to distinguish different possible\n\tPHY types, but not in a consistent way.  Deprecated.\n @autoneg: Enable/disable autonegotiation and auto-detection;\n\teither %AUTONEG_DISABLE or %AUTONEG_ENABLE\n @mdio_support: Bitmask of %ETH_MDIO_SUPPORTS_* flags for the MDIO\n\tprotocols supported by the interface; 0 if unknown.\n\tRead-only.\n @maxtxpkt: Historically used to report TX IRQ coalescing; now\n\tobsoleted by &struct ethtool_coalesce.  Read-only; deprecated.\n @maxrxpkt: Historically used to report RX IRQ coalescing; now\n\tobsoleted by &struct ethtool_coalesce.  Read-only; deprecated.\n @speed_hi: High bits of the speed, 1Mb units, 0 to INT_MAX or SPEED_UNKNOWN\n @eth_tp_mdix: Ethernet twisted-pair MDI(-X) status; one of\n\t%ETH_TP_MDI_*.  If the status is unknown or not applicable, the\n\tvalue will be %ETH_TP_MDI_INVALID.  Read-only.\n @eth_tp_mdix_ctrl: Ethernet twisted pair MDI(-X) control; one of\n\t%ETH_TP_MDI_*.  If MDI(-X) control is not implemented, reads\n\tyield %ETH_TP_MDI_INVALID and writes may be ignored or rejected.\n\tWhen written successfully, the link should be renegotiated if\n\tnecessary.\n @lp_advertising: Bitmask of %ADVERTISED_* flags for the link modes\n\tand other link features that the link partner advertised\n\tthrough autonegotiation; 0 if unknown or not applicable.\n\tRead-only.\n @reserved: Reserved for future use; see the note on reserved space.\n\n The link speed in Mbps is split between @speed and @speed_hi.  Use\n the ethtool_cmd_speed() and ethtool_cmd_speed_set() functions to\n access it.\n\n If autonegotiation is disabled, the speed and @duplex represent the\n fixed link mode and are writable if the driver supports multiple\n link modes.  If it is enabled then they are read-only; if the link\n is up they represent the negotiated link mode; if the link is down,\n the speed is 0, %SPEED_UNKNOWN or the highest enabled speed and\n @duplex is %DUPLEX_UNKNOWN or the best enabled duplex mode.\n\n Some hardware interfaces may have multiple PHYs and/or physical\n connectors fitted or do not allow the driver to detect which are\n fitted.  For these interfaces @port and/or @phy_address may be\n writable, possibly dependent on @autoneg being %AUTONEG_DISABLE.\n Otherwise, attempts to write different values may be ignored or\n rejected.\n\n Users should assume that all fields not marked read-only are\n writable and subject to validation by the driver.  They should use\n %ETHTOOL_GSET to get the current values before making specific\n changes and then applying them with %ETHTOOL_SSET.\n\n Deprecated fields should be ignored by both users and drivers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_cmd {
    pub cmd: __u32,
    pub supported: __u32,
    pub advertising: __u32,
    pub speed: __u16,
    pub duplex: __u8,
    pub port: __u8,
    pub phy_address: __u8,
    pub transceiver: __u8,
    pub autoneg: __u8,
    pub mdio_support: __u8,
    pub maxtxpkt: __u32,
    pub maxrxpkt: __u32,
    pub speed_hi: __u16,
    pub eth_tp_mdix: __u8,
    pub eth_tp_mdix_ctrl: __u8,
    pub lp_advertising: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_ethtool_cmd() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_cmd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_cmd>(),
        44usize,
        concat!("Size of: ", stringify!(ethtool_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_cmd>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_cmd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).advertising) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(advertising)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duplex) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(duplex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phy_address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(phy_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transceiver) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(transceiver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autoneg) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(autoneg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mdio_support) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(mdio_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxtxpkt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(maxtxpkt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxrxpkt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(maxrxpkt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed_hi) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(speed_hi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eth_tp_mdix) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(eth_tp_mdix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eth_tp_mdix_ctrl) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(eth_tp_mdix_ctrl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lp_advertising) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(lp_advertising)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_cmd),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct ethtool_drvinfo - general driver and device information\n @cmd: Command number = %ETHTOOL_GDRVINFO\n @driver: Driver short name.  This should normally match the name\n\tin its bus driver structure (e.g. pci_driver::name).  Must\n\tnot be an empty string.\n @version: Driver version string; may be an empty string\n @fw_version: Firmware version string; driver defined; may be an\n\tempty string\n @erom_version: Expansion ROM version string; driver defined; may be\n\tan empty string\n @bus_info: Device bus address.  This should match the dev_name()\n\tstring for the underlying bus device, if there is one.  May be\n\tan empty string.\n @reserved2: Reserved for future use; see the note on reserved space.\n @n_priv_flags: Number of flags valid for %ETHTOOL_GPFLAGS and\n\t%ETHTOOL_SPFLAGS commands; also the number of strings in the\n\t%ETH_SS_PRIV_FLAGS set\n @n_stats: Number of u64 statistics returned by the %ETHTOOL_GSTATS\n\tcommand; also the number of strings in the %ETH_SS_STATS set\n @testinfo_len: Number of results returned by the %ETHTOOL_TEST\n\tcommand; also the number of strings in the %ETH_SS_TEST set\n @eedump_len: Size of EEPROM accessible through the %ETHTOOL_GEEPROM\n\tand %ETHTOOL_SEEPROM commands, in bytes\n @regdump_len: Size of register dump returned by the %ETHTOOL_GREGS\n\tcommand, in bytes\n\n Users can use the %ETHTOOL_GSSET_INFO command to get the number of\n strings in any string set (from Linux 2.6.34)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_drvinfo {
    pub cmd: __u32,
    pub driver: [::std::os::raw::c_char; 32usize],
    pub version: [::std::os::raw::c_char; 32usize],
    pub fw_version: [::std::os::raw::c_char; 32usize],
    pub bus_info: [::std::os::raw::c_char; 32usize],
    pub erom_version: [::std::os::raw::c_char; 32usize],
    pub reserved2: [::std::os::raw::c_char; 12usize],
    pub n_priv_flags: __u32,
    pub n_stats: __u32,
    pub testinfo_len: __u32,
    pub eedump_len: __u32,
    pub regdump_len: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_drvinfo() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_drvinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_drvinfo>(),
        196usize,
        concat!("Size of: ", stringify!(ethtool_drvinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_drvinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_drvinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fw_version) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(fw_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bus_info) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(bus_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).erom_version) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(erom_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_priv_flags) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(n_priv_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_stats) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(n_stats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).testinfo_len) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(testinfo_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eedump_len) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(eedump_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regdump_len) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_drvinfo),
            "::",
            stringify!(regdump_len)
        )
    );
}
#[doc = " struct ethtool_wolinfo - Wake-On-Lan configuration\n @cmd: Command number = %ETHTOOL_GWOL or %ETHTOOL_SWOL\n @supported: Bitmask of %WAKE_* flags for supported Wake-On-Lan modes.\n\tRead-only.\n @wolopts: Bitmask of %WAKE_* flags for enabled Wake-On-Lan modes.\n @sopass: SecureOn(tm) password; meaningful only if %WAKE_MAGICSECURE\n\tis set in @wolopts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_wolinfo {
    pub cmd: __u32,
    pub supported: __u32,
    pub wolopts: __u32,
    pub sopass: [__u8; 6usize],
}
#[test]
fn bindgen_test_layout_ethtool_wolinfo() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_wolinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_wolinfo>(),
        20usize,
        concat!("Size of: ", stringify!(ethtool_wolinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_wolinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_wolinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_wolinfo),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_wolinfo),
            "::",
            stringify!(supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wolopts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_wolinfo),
            "::",
            stringify!(wolopts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sopass) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_wolinfo),
            "::",
            stringify!(sopass)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_value {
    pub cmd: __u32,
    pub data: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_value() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_value>(),
        8usize,
        concat!("Size of: ", stringify!(ethtool_value))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_value>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_value),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_value),
            "::",
            stringify!(data)
        )
    );
}
pub const tunable_id_ETHTOOL_ID_UNSPEC: tunable_id = 0;
pub const tunable_id_ETHTOOL_RX_COPYBREAK: tunable_id = 1;
pub const tunable_id_ETHTOOL_TX_COPYBREAK: tunable_id = 2;
pub const tunable_id_ETHTOOL_PFC_PREVENTION_TOUT: tunable_id = 3;
pub const tunable_id_ETHTOOL_TX_COPYBREAK_BUF_SIZE: tunable_id = 4;
pub const tunable_id___ETHTOOL_TUNABLE_COUNT: tunable_id = 5;
pub type tunable_id = ::std::os::raw::c_uint;
pub const tunable_type_id_ETHTOOL_TUNABLE_UNSPEC: tunable_type_id = 0;
pub const tunable_type_id_ETHTOOL_TUNABLE_U8: tunable_type_id = 1;
pub const tunable_type_id_ETHTOOL_TUNABLE_U16: tunable_type_id = 2;
pub const tunable_type_id_ETHTOOL_TUNABLE_U32: tunable_type_id = 3;
pub const tunable_type_id_ETHTOOL_TUNABLE_U64: tunable_type_id = 4;
pub const tunable_type_id_ETHTOOL_TUNABLE_STRING: tunable_type_id = 5;
pub const tunable_type_id_ETHTOOL_TUNABLE_S8: tunable_type_id = 6;
pub const tunable_type_id_ETHTOOL_TUNABLE_S16: tunable_type_id = 7;
pub const tunable_type_id_ETHTOOL_TUNABLE_S32: tunable_type_id = 8;
pub const tunable_type_id_ETHTOOL_TUNABLE_S64: tunable_type_id = 9;
pub type tunable_type_id = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_tunable {
    pub cmd: __u32,
    pub id: __u32,
    pub type_id: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_ethtool_tunable() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_tunable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_tunable>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_tunable))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_tunable>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_tunable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(type_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tunable),
            "::",
            stringify!(data)
        )
    );
}
pub const phy_tunable_id_ETHTOOL_PHY_ID_UNSPEC: phy_tunable_id = 0;
pub const phy_tunable_id_ETHTOOL_PHY_DOWNSHIFT: phy_tunable_id = 1;
pub const phy_tunable_id_ETHTOOL_PHY_FAST_LINK_DOWN: phy_tunable_id = 2;
pub const phy_tunable_id_ETHTOOL_PHY_EDPD: phy_tunable_id = 3;
pub const phy_tunable_id___ETHTOOL_PHY_TUNABLE_COUNT: phy_tunable_id = 4;
pub type phy_tunable_id = ::std::os::raw::c_uint;
#[doc = " struct ethtool_regs - hardware register dump\n @cmd: Command number = %ETHTOOL_GREGS\n @version: Dump format version.  This is driver-specific and may\n\tdistinguish different chips/revisions.  Drivers must use new\n\tversion numbers whenever the dump format changes in an\n\tincompatible way.\n @len: On entry, the real length of @data.  On return, the number of\n\tbytes used.\n @data: Buffer for the register dump\n\n Users should use %ETHTOOL_GDRVINFO to find the maximum length of\n a register dump for the interface.  They must allocate the buffer\n immediately following this structure."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_regs {
    pub cmd: __u32,
    pub version: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_ethtool_regs() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_regs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_regs>(),
        12usize,
        concat!("Size of: ", stringify!(ethtool_regs))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_regs>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_regs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_regs),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_regs),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_regs),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_regs),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_eeprom - EEPROM dump\n @cmd: Command number = %ETHTOOL_GEEPROM, %ETHTOOL_GMODULEEEPROM or\n\t%ETHTOOL_SEEPROM\n @magic: A 'magic cookie' value to guard against accidental changes.\n\tThe value passed in to %ETHTOOL_SEEPROM must match the value\n\treturned by %ETHTOOL_GEEPROM for the same device.  This is\n\tunused when @cmd is %ETHTOOL_GMODULEEEPROM.\n @offset: Offset within the EEPROM to begin reading/writing, in bytes\n @len: On entry, number of bytes to read/write.  On successful\n\treturn, number of bytes actually read/written.  In case of\n\terror, this may indicate at what point the error occurred.\n @data: Buffer to read/write from\n\n Users may use %ETHTOOL_GDRVINFO or %ETHTOOL_GMODULEINFO to find\n the length of an on-board or module EEPROM, respectively.  They\n must allocate the buffer immediately following this structure."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_eeprom {
    pub cmd: __u32,
    pub magic: __u32,
    pub offset: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_ethtool_eeprom() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_eeprom> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_eeprom>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_eeprom))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_eeprom>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_eeprom))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eeprom),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_eee - Energy Efficient Ethernet information\n @cmd: ETHTOOL_{G,S}EEE\n @supported: Mask of %SUPPORTED_* flags for the speed/duplex combinations\n\tfor which there is EEE support.\n @advertised: Mask of %ADVERTISED_* flags for the speed/duplex combinations\n\tadvertised as eee capable.\n @lp_advertised: Mask of %ADVERTISED_* flags for the speed/duplex\n\tcombinations advertised by the link partner as eee capable.\n @eee_active: Result of the eee auto negotiation.\n @eee_enabled: EEE configured mode (enabled/disabled).\n @tx_lpi_enabled: Whether the interface should assert its tx lpi, given\n\tthat eee was negotiated.\n @tx_lpi_timer: Time in microseconds the interface delays prior to asserting\n\tits tx lpi (after reaching 'idle' state). Effective only when eee\n\twas negotiated and tx_lpi_enabled was set.\n @reserved: Reserved for future use; see the note on reserved space."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_eee {
    pub cmd: __u32,
    pub supported: __u32,
    pub advertised: __u32,
    pub lp_advertised: __u32,
    pub eee_active: __u32,
    pub eee_enabled: __u32,
    pub tx_lpi_enabled: __u32,
    pub tx_lpi_timer: __u32,
    pub reserved: [__u32; 2usize],
}
#[test]
fn bindgen_test_layout_ethtool_eee() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_eee> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_eee>(),
        40usize,
        concat!("Size of: ", stringify!(ethtool_eee))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_eee>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_eee))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).advertised) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(advertised)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lp_advertised) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(lp_advertised)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eee_active) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(eee_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eee_enabled) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(eee_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_lpi_enabled) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(tx_lpi_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_lpi_timer) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(tx_lpi_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_eee),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct ethtool_modinfo - plugin module eeprom information\n @cmd: %ETHTOOL_GMODULEINFO\n @type: Standard the module information conforms to %ETH_MODULE_SFF_xxxx\n @eeprom_len: Length of the eeprom\n @reserved: Reserved for future use; see the note on reserved space.\n\n This structure is used to return the information to\n properly size memory for a subsequent call to %ETHTOOL_GMODULEEEPROM.\n The type code indicates the eeprom data format"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_modinfo {
    pub cmd: __u32,
    pub type_: __u32,
    pub eeprom_len: __u32,
    pub reserved: [__u32; 8usize],
}
#[test]
fn bindgen_test_layout_ethtool_modinfo() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_modinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_modinfo>(),
        44usize,
        concat!("Size of: ", stringify!(ethtool_modinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_modinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_modinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_modinfo),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_modinfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eeprom_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_modinfo),
            "::",
            stringify!(eeprom_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_modinfo),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct ethtool_coalesce - coalescing parameters for IRQs and stats updates\n @cmd: ETHTOOL_{G,S}COALESCE\n @rx_coalesce_usecs: How many usecs to delay an RX interrupt after\n\ta packet arrives.\n @rx_max_coalesced_frames: Maximum number of packets to receive\n\tbefore an RX interrupt.\n @rx_coalesce_usecs_irq: Same as @rx_coalesce_usecs, except that\n\tthis value applies while an IRQ is being serviced by the host.\n @rx_max_coalesced_frames_irq: Same as @rx_max_coalesced_frames,\n\texcept that this value applies while an IRQ is being serviced\n\tby the host.\n @tx_coalesce_usecs: How many usecs to delay a TX interrupt after\n\ta packet is sent.\n @tx_max_coalesced_frames: Maximum number of packets to be sent\n\tbefore a TX interrupt.\n @tx_coalesce_usecs_irq: Same as @tx_coalesce_usecs, except that\n\tthis value applies while an IRQ is being serviced by the host.\n @tx_max_coalesced_frames_irq: Same as @tx_max_coalesced_frames,\n\texcept that this value applies while an IRQ is being serviced\n\tby the host.\n @stats_block_coalesce_usecs: How many usecs to delay in-memory\n\tstatistics block updates.  Some drivers do not have an\n\tin-memory statistic block, and in such cases this value is\n\tignored.  This value must not be zero.\n @use_adaptive_rx_coalesce: Enable adaptive RX coalescing.\n @use_adaptive_tx_coalesce: Enable adaptive TX coalescing.\n @pkt_rate_low: Threshold for low packet rate (packets per second).\n @rx_coalesce_usecs_low: How many usecs to delay an RX interrupt after\n\ta packet arrives, when the packet rate is below @pkt_rate_low.\n @rx_max_coalesced_frames_low: Maximum number of packets to be received\n\tbefore an RX interrupt, when the packet rate is below @pkt_rate_low.\n @tx_coalesce_usecs_low: How many usecs to delay a TX interrupt after\n\ta packet is sent, when the packet rate is below @pkt_rate_low.\n @tx_max_coalesced_frames_low: Maximum nuumber of packets to be sent before\n\ta TX interrupt, when the packet rate is below @pkt_rate_low.\n @pkt_rate_high: Threshold for high packet rate (packets per second).\n @rx_coalesce_usecs_high: How many usecs to delay an RX interrupt after\n\ta packet arrives, when the packet rate is above @pkt_rate_high.\n @rx_max_coalesced_frames_high: Maximum number of packets to be received\n\tbefore an RX interrupt, when the packet rate is above @pkt_rate_high.\n @tx_coalesce_usecs_high: How many usecs to delay a TX interrupt after\n\ta packet is sent, when the packet rate is above @pkt_rate_high.\n @tx_max_coalesced_frames_high: Maximum number of packets to be sent before\n\ta TX interrupt, when the packet rate is above @pkt_rate_high.\n @rate_sample_interval: How often to do adaptive coalescing packet rate\n\tsampling, measured in seconds.  Must not be zero.\n\n Each pair of (usecs, max_frames) fields specifies that interrupts\n should be coalesced until\n\t(usecs > 0 && time_since_first_completion >= usecs) ||\n\t(max_frames > 0 && completed_frames >= max_frames)\n\n It is illegal to set both usecs and max_frames to zero as this\n would cause interrupts to never be generated.  To disable\n coalescing, set usecs = 0 and max_frames = 1.\n\n Some implementations ignore the value of max_frames and use the\n condition time_since_first_completion >= usecs\n\n This is deprecated.  Drivers for hardware that does not support\n counting completions should validate that max_frames == !rx_usecs.\n\n Adaptive RX/TX coalescing is an algorithm implemented by some\n drivers to improve latency under low packet rates and improve\n throughput under high packet rates.  Some drivers only implement\n one of RX or TX adaptive coalescing.  Anything not implemented by\n the driver causes these values to be silently ignored.\n\n When the packet rate is below @pkt_rate_high but above\n @pkt_rate_low (both measured in packets per second) the\n normal {rx,tx}_* coalescing parameters are used."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_coalesce {
    pub cmd: __u32,
    pub rx_coalesce_usecs: __u32,
    pub rx_max_coalesced_frames: __u32,
    pub rx_coalesce_usecs_irq: __u32,
    pub rx_max_coalesced_frames_irq: __u32,
    pub tx_coalesce_usecs: __u32,
    pub tx_max_coalesced_frames: __u32,
    pub tx_coalesce_usecs_irq: __u32,
    pub tx_max_coalesced_frames_irq: __u32,
    pub stats_block_coalesce_usecs: __u32,
    pub use_adaptive_rx_coalesce: __u32,
    pub use_adaptive_tx_coalesce: __u32,
    pub pkt_rate_low: __u32,
    pub rx_coalesce_usecs_low: __u32,
    pub rx_max_coalesced_frames_low: __u32,
    pub tx_coalesce_usecs_low: __u32,
    pub tx_max_coalesced_frames_low: __u32,
    pub pkt_rate_high: __u32,
    pub rx_coalesce_usecs_high: __u32,
    pub rx_max_coalesced_frames_high: __u32,
    pub tx_coalesce_usecs_high: __u32,
    pub tx_max_coalesced_frames_high: __u32,
    pub rate_sample_interval: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_coalesce() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_coalesce> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_coalesce>(),
        92usize,
        concat!("Size of: ", stringify!(ethtool_coalesce))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_coalesce>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_coalesce))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_coalesce_usecs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_coalesce_usecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_max_coalesced_frames) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_max_coalesced_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_coalesce_usecs_irq) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_coalesce_usecs_irq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_max_coalesced_frames_irq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_max_coalesced_frames_irq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_coalesce_usecs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_coalesce_usecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_max_coalesced_frames) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_max_coalesced_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_coalesce_usecs_irq) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_coalesce_usecs_irq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_max_coalesced_frames_irq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_max_coalesced_frames_irq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stats_block_coalesce_usecs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(stats_block_coalesce_usecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_adaptive_rx_coalesce) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(use_adaptive_rx_coalesce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_adaptive_tx_coalesce) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(use_adaptive_tx_coalesce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_rate_low) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(pkt_rate_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_coalesce_usecs_low) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_coalesce_usecs_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_max_coalesced_frames_low) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_max_coalesced_frames_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_coalesce_usecs_low) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_coalesce_usecs_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_max_coalesced_frames_low) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_max_coalesced_frames_low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pkt_rate_high) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(pkt_rate_high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_coalesce_usecs_high) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_coalesce_usecs_high)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).rx_max_coalesced_frames_high) as usize - ptr as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rx_max_coalesced_frames_high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_coalesce_usecs_high) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_coalesce_usecs_high)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).tx_max_coalesced_frames_high) as usize - ptr as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(tx_max_coalesced_frames_high)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate_sample_interval) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_coalesce),
            "::",
            stringify!(rate_sample_interval)
        )
    );
}
#[doc = " struct ethtool_ringparam - RX/TX ring parameters\n @cmd: Command number = %ETHTOOL_GRINGPARAM or %ETHTOOL_SRINGPARAM\n @rx_max_pending: Maximum supported number of pending entries per\n\tRX ring.  Read-only.\n @rx_mini_max_pending: Maximum supported number of pending entries\n\tper RX mini ring.  Read-only.\n @rx_jumbo_max_pending: Maximum supported number of pending entries\n\tper RX jumbo ring.  Read-only.\n @tx_max_pending: Maximum supported number of pending entries per\n\tTX ring.  Read-only.\n @rx_pending: Current maximum number of pending entries per RX ring\n @rx_mini_pending: Current maximum number of pending entries per RX\n\tmini ring\n @rx_jumbo_pending: Current maximum number of pending entries per RX\n\tjumbo ring\n @tx_pending: Current maximum supported number of pending entries\n\tper TX ring\n\n If the interface does not have separate RX mini and/or jumbo rings,\n @rx_mini_max_pending and/or @rx_jumbo_max_pending will be 0.\n\n There may also be driver-dependent minimum values for the number\n of entries per ring."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ringparam {
    pub cmd: __u32,
    pub rx_max_pending: __u32,
    pub rx_mini_max_pending: __u32,
    pub rx_jumbo_max_pending: __u32,
    pub tx_max_pending: __u32,
    pub rx_pending: __u32,
    pub rx_mini_pending: __u32,
    pub rx_jumbo_pending: __u32,
    pub tx_pending: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_ringparam() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_ringparam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_ringparam>(),
        36usize,
        concat!("Size of: ", stringify!(ethtool_ringparam))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_ringparam>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_ringparam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_max_pending) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_max_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_mini_max_pending) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_mini_max_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_jumbo_max_pending) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_jumbo_max_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_max_pending) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(tx_max_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_pending) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_mini_pending) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_mini_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_jumbo_pending) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(rx_jumbo_pending)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_pending) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ringparam),
            "::",
            stringify!(tx_pending)
        )
    );
}
#[doc = " struct ethtool_channels - configuring number of network channel\n @cmd: ETHTOOL_{G,S}CHANNELS\n @max_rx: Read only. Maximum number of receive channel the driver support.\n @max_tx: Read only. Maximum number of transmit channel the driver support.\n @max_other: Read only. Maximum number of other channel the driver support.\n @max_combined: Read only. Maximum number of combined channel the driver\n\tsupport. Set of queues RX, TX or other.\n @rx_count: Valid values are in the range 1 to the max_rx.\n @tx_count: Valid values are in the range 1 to the max_tx.\n @other_count: Valid values are in the range 1 to the max_other.\n @combined_count: Valid values are in the range 1 to the max_combined.\n\n This can be used to configure RX, TX and other channels."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_channels {
    pub cmd: __u32,
    pub max_rx: __u32,
    pub max_tx: __u32,
    pub max_other: __u32,
    pub max_combined: __u32,
    pub rx_count: __u32,
    pub tx_count: __u32,
    pub other_count: __u32,
    pub combined_count: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_channels() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_channels> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_channels>(),
        36usize,
        concat!("Size of: ", stringify!(ethtool_channels))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_channels>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_channels))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_rx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(max_rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_tx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(max_tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_other) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(max_other)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_combined) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(max_combined)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(rx_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(tx_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).other_count) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(other_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).combined_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_channels),
            "::",
            stringify!(combined_count)
        )
    );
}
#[doc = " struct ethtool_pauseparam - Ethernet pause (flow control) parameters\n @cmd: Command number = %ETHTOOL_GPAUSEPARAM or %ETHTOOL_SPAUSEPARAM\n @autoneg: Flag to enable autonegotiation of pause frame use\n @rx_pause: Flag to enable reception of pause frames\n @tx_pause: Flag to enable transmission of pause frames\n\n Drivers should reject a non-zero setting of @autoneg when\n autoneogotiation is disabled (or not supported) for the link.\n\n If the link is autonegotiated, drivers should use\n mii_advertise_flowctrl() or similar code to set the advertised\n pause frame capabilities based on the @rx_pause and @tx_pause flags,\n even if @autoneg is zero.  They should also allow the advertised\n pause frame capabilities to be controlled directly through the\n advertising field of &struct ethtool_cmd.\n\n If @autoneg is non-zero, the MAC is configured to send and/or\n receive pause frames according to the result of autonegotiation.\n Otherwise, it is configured directly based on the @rx_pause and\n @tx_pause flags."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_pauseparam {
    pub cmd: __u32,
    pub autoneg: __u32,
    pub rx_pause: __u32,
    pub tx_pause: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_pauseparam() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_pauseparam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_pauseparam>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_pauseparam))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_pauseparam>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_pauseparam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_pauseparam),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autoneg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_pauseparam),
            "::",
            stringify!(autoneg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_pause) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_pauseparam),
            "::",
            stringify!(rx_pause)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_pause) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_pauseparam),
            "::",
            stringify!(tx_pause)
        )
    );
}
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_AUTONEG: ethtool_link_ext_state = 0;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE:
    ethtool_link_ext_state = 1;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH:
    ethtool_link_ext_state = 2;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY:
    ethtool_link_ext_state = 3;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_NO_CABLE: ethtool_link_ext_state = 4;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE: ethtool_link_ext_state = 5;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE: ethtool_link_ext_state = 6;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE:
    ethtool_link_ext_state = 7;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED:
    ethtool_link_ext_state = 8;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_OVERHEAT: ethtool_link_ext_state = 9;
pub const ethtool_link_ext_state_ETHTOOL_LINK_EXT_STATE_MODULE: ethtool_link_ext_state = 10;
pub type ethtool_link_ext_state = ::std::os::raw::c_uint;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED:
    ethtool_link_ext_substate_autoneg = 1;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED:
    ethtool_link_ext_substate_autoneg = 2;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED : ethtool_link_ext_substate_autoneg = 3 ;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE : ethtool_link_ext_substate_autoneg = 4 ;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE : ethtool_link_ext_substate_autoneg = 5 ;
pub const ethtool_link_ext_substate_autoneg_ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD:
    ethtool_link_ext_substate_autoneg = 6;
pub type ethtool_link_ext_substate_autoneg = ::std::os::raw::c_uint;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED : ethtool_link_ext_substate_link_training = 1 ;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT : ethtool_link_ext_substate_link_training = 2 ;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY : ethtool_link_ext_substate_link_training = 3 ;
pub const ethtool_link_ext_substate_link_training_ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT:
    ethtool_link_ext_substate_link_training = 4;
pub type ethtool_link_ext_substate_link_training = ::std::os::raw::c_uint;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK : ethtool_link_ext_substate_link_logical_mismatch = 1 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK : ethtool_link_ext_substate_link_logical_mismatch = 2 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS : ethtool_link_ext_substate_link_logical_mismatch = 3 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED : ethtool_link_ext_substate_link_logical_mismatch = 4 ;
pub const ethtool_link_ext_substate_link_logical_mismatch_ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED : ethtool_link_ext_substate_link_logical_mismatch = 5 ;
pub type ethtool_link_ext_substate_link_logical_mismatch = ::std::os::raw::c_uint;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS : ethtool_link_ext_substate_bad_signal_integrity = 1 ;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE : ethtool_link_ext_substate_bad_signal_integrity = 2 ;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST : ethtool_link_ext_substate_bad_signal_integrity = 3 ;
pub const ethtool_link_ext_substate_bad_signal_integrity_ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS : ethtool_link_ext_substate_bad_signal_integrity = 4 ;
pub type ethtool_link_ext_substate_bad_signal_integrity = ::std::os::raw::c_uint;
pub const ethtool_link_ext_substate_cable_issue_ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE:
    ethtool_link_ext_substate_cable_issue = 1;
pub const ethtool_link_ext_substate_cable_issue_ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE:
    ethtool_link_ext_substate_cable_issue = 2;
pub type ethtool_link_ext_substate_cable_issue = ::std::os::raw::c_uint;
pub const ethtool_link_ext_substate_module_ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY:
    ethtool_link_ext_substate_module = 1;
pub type ethtool_link_ext_substate_module = ::std::os::raw::c_uint;
pub const ethtool_stringset_ETH_SS_TEST: ethtool_stringset = 0;
pub const ethtool_stringset_ETH_SS_STATS: ethtool_stringset = 1;
pub const ethtool_stringset_ETH_SS_PRIV_FLAGS: ethtool_stringset = 2;
pub const ethtool_stringset_ETH_SS_NTUPLE_FILTERS: ethtool_stringset = 3;
pub const ethtool_stringset_ETH_SS_FEATURES: ethtool_stringset = 4;
pub const ethtool_stringset_ETH_SS_RSS_HASH_FUNCS: ethtool_stringset = 5;
pub const ethtool_stringset_ETH_SS_TUNABLES: ethtool_stringset = 6;
pub const ethtool_stringset_ETH_SS_PHY_STATS: ethtool_stringset = 7;
pub const ethtool_stringset_ETH_SS_PHY_TUNABLES: ethtool_stringset = 8;
pub const ethtool_stringset_ETH_SS_LINK_MODES: ethtool_stringset = 9;
pub const ethtool_stringset_ETH_SS_MSG_CLASSES: ethtool_stringset = 10;
pub const ethtool_stringset_ETH_SS_WOL_MODES: ethtool_stringset = 11;
pub const ethtool_stringset_ETH_SS_SOF_TIMESTAMPING: ethtool_stringset = 12;
pub const ethtool_stringset_ETH_SS_TS_TX_TYPES: ethtool_stringset = 13;
pub const ethtool_stringset_ETH_SS_TS_RX_FILTERS: ethtool_stringset = 14;
pub const ethtool_stringset_ETH_SS_UDP_TUNNEL_TYPES: ethtool_stringset = 15;
pub const ethtool_stringset_ETH_SS_STATS_STD: ethtool_stringset = 16;
pub const ethtool_stringset_ETH_SS_STATS_ETH_PHY: ethtool_stringset = 17;
pub const ethtool_stringset_ETH_SS_STATS_ETH_MAC: ethtool_stringset = 18;
pub const ethtool_stringset_ETH_SS_STATS_ETH_CTRL: ethtool_stringset = 19;
pub const ethtool_stringset_ETH_SS_STATS_RMON: ethtool_stringset = 20;
pub const ethtool_stringset_ETH_SS_COUNT: ethtool_stringset = 21;
#[doc = " enum ethtool_stringset - string set ID\n @ETH_SS_TEST: Self-test result names, for use with %ETHTOOL_TEST\n @ETH_SS_STATS: Statistic names, for use with %ETHTOOL_GSTATS\n @ETH_SS_PRIV_FLAGS: Driver private flag names, for use with\n\t%ETHTOOL_GPFLAGS and %ETHTOOL_SPFLAGS\n @ETH_SS_NTUPLE_FILTERS: Previously used with %ETHTOOL_GRXNTUPLE;\n\tnow deprecated\n @ETH_SS_FEATURES: Device feature names\n @ETH_SS_RSS_HASH_FUNCS: RSS hush function names\n @ETH_SS_TUNABLES: tunable names\n @ETH_SS_PHY_STATS: Statistic names, for use with %ETHTOOL_GPHYSTATS\n @ETH_SS_PHY_TUNABLES: PHY tunable names\n @ETH_SS_LINK_MODES: link mode names\n @ETH_SS_MSG_CLASSES: debug message class names\n @ETH_SS_WOL_MODES: wake-on-lan modes\n @ETH_SS_SOF_TIMESTAMPING: SOF_TIMESTAMPING_* flags\n @ETH_SS_TS_TX_TYPES: timestamping Tx types\n @ETH_SS_TS_RX_FILTERS: timestamping Rx filters\n @ETH_SS_UDP_TUNNEL_TYPES: UDP tunnel types\n @ETH_SS_STATS_STD: standardized stats\n @ETH_SS_STATS_ETH_PHY: names of IEEE 802.3 PHY statistics\n @ETH_SS_STATS_ETH_MAC: names of IEEE 802.3 MAC statistics\n @ETH_SS_STATS_ETH_CTRL: names of IEEE 802.3 MAC Control statistics\n @ETH_SS_STATS_RMON: names of RMON statistics\n\n @ETH_SS_COUNT: number of defined string sets"]
pub type ethtool_stringset = ::std::os::raw::c_uint;
pub const ethtool_mac_stats_src_ETHTOOL_MAC_STATS_SRC_AGGREGATE: ethtool_mac_stats_src = 0;
pub const ethtool_mac_stats_src_ETHTOOL_MAC_STATS_SRC_EMAC: ethtool_mac_stats_src = 1;
pub const ethtool_mac_stats_src_ETHTOOL_MAC_STATS_SRC_PMAC: ethtool_mac_stats_src = 2;
#[doc = " enum ethtool_mac_stats_src - source of ethtool MAC statistics\n @ETHTOOL_MAC_STATS_SRC_AGGREGATE:\n\tif device supports a MAC merge layer, this retrieves the aggregate\n\tstatistics of the eMAC and pMAC. Otherwise, it retrieves just the\n\tstatistics of the single (express) MAC.\n @ETHTOOL_MAC_STATS_SRC_EMAC:\n\tif device supports a MM layer, this retrieves the eMAC statistics.\n\tOtherwise, it retrieves the statistics of the single (express) MAC.\n @ETHTOOL_MAC_STATS_SRC_PMAC:\n\tif device supports a MM layer, this retrieves the pMAC statistics."]
pub type ethtool_mac_stats_src = ::std::os::raw::c_uint;
pub const ethtool_module_power_mode_policy_ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH:
    ethtool_module_power_mode_policy = 1;
pub const ethtool_module_power_mode_policy_ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO:
    ethtool_module_power_mode_policy = 2;
#[doc = " enum ethtool_module_power_mode_policy - plug-in module power mode policy\n @ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH: Module is always in high power mode.\n @ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO: Module is transitioned by the host\n\tto high power mode when the first port using it is put administratively\n\tup and to low power mode when the last port using it is put\n\tadministratively down."]
pub type ethtool_module_power_mode_policy = ::std::os::raw::c_uint;
pub const ethtool_module_power_mode_ETHTOOL_MODULE_POWER_MODE_LOW: ethtool_module_power_mode = 1;
pub const ethtool_module_power_mode_ETHTOOL_MODULE_POWER_MODE_HIGH: ethtool_module_power_mode = 2;
#[doc = " enum ethtool_module_power_mode - plug-in module power mode\n @ETHTOOL_MODULE_POWER_MODE_LOW: Module is in low power mode.\n @ETHTOOL_MODULE_POWER_MODE_HIGH: Module is in high power mode."]
pub type ethtool_module_power_mode = ::std::os::raw::c_uint;
pub const ethtool_podl_pse_admin_state_ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN:
    ethtool_podl_pse_admin_state = 1;
pub const ethtool_podl_pse_admin_state_ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED:
    ethtool_podl_pse_admin_state = 2;
pub const ethtool_podl_pse_admin_state_ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED:
    ethtool_podl_pse_admin_state = 3;
#[doc = " enum ethtool_podl_pse_admin_state - operational state of the PoDL PSE\n\tfunctions. IEEE 802.3-2018 30.15.1.1.2 aPoDLPSEAdminState\n @ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN: state of PoDL PSE functions are\n \tunknown\n @ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED: PoDL PSE functions are disabled\n @ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED: PoDL PSE functions are enabled"]
pub type ethtool_podl_pse_admin_state = ::std::os::raw::c_uint;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN:
    ethtool_podl_pse_pw_d_status = 1;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED:
    ethtool_podl_pse_pw_d_status = 2;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING:
    ethtool_podl_pse_pw_d_status = 3;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING:
    ethtool_podl_pse_pw_d_status = 4;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP:
    ethtool_podl_pse_pw_d_status = 5;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE:
    ethtool_podl_pse_pw_d_status = 6;
pub const ethtool_podl_pse_pw_d_status_ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR:
    ethtool_podl_pse_pw_d_status = 7;
#[doc = " enum ethtool_podl_pse_pw_d_status - power detection status of the PoDL PSE.\n\tIEEE 802.3-2018 30.15.1.1.3 aPoDLPSEPowerDetectionStatus:\n @ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN: PoDL PSE\n @ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED: \"The enumeration “disabled” is\n\tasserted true when the PoDL PSE state diagram variable mr_pse_enable is\n\tfalse\"\n @ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING: \"The enumeration “searching” is\n\tasserted true when either of the PSE state diagram variables\n\tpi_detecting or pi_classifying is true.\"\n @ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING: \"The enumeration “deliveringPower”\n\tis asserted true when the PoDL PSE state diagram variable pi_powered is\n\ttrue.\"\n @ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP: \"The enumeration “sleep” is asserted\n\ttrue when the PoDL PSE state diagram variable pi_sleeping is true.\"\n @ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE: \"The enumeration “idle” is asserted true\n\twhen the logical combination of the PoDL PSE state diagram variables\n\tpi_prebiased*!pi_sleeping is true.\"\n @ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR: \"The enumeration “error” is asserted\n\ttrue when the PoDL PSE state diagram variable overload_held is true.\""]
pub type ethtool_podl_pse_pw_d_status = ::std::os::raw::c_uint;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_UNKNOWN: ethtool_mm_verify_status = 0;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_INITIAL: ethtool_mm_verify_status = 1;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_VERIFYING: ethtool_mm_verify_status = 2;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED: ethtool_mm_verify_status = 3;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_FAILED: ethtool_mm_verify_status = 4;
pub const ethtool_mm_verify_status_ETHTOOL_MM_VERIFY_STATUS_DISABLED: ethtool_mm_verify_status = 5;
#[doc = " enum ethtool_mm_verify_status - status of MAC Merge Verify function\n @ETHTOOL_MM_VERIFY_STATUS_UNKNOWN:\n\tverification status is unknown\n @ETHTOOL_MM_VERIFY_STATUS_INITIAL:\n\tthe 802.3 Verify State diagram is in the state INIT_VERIFICATION\n @ETHTOOL_MM_VERIFY_STATUS_VERIFYING:\n\tthe Verify State diagram is in the state VERIFICATION_IDLE,\n\tSEND_VERIFY or WAIT_FOR_RESPONSE\n @ETHTOOL_MM_VERIFY_STATUS_SUCCEEDED:\n\tindicates that the Verify State diagram is in the state VERIFIED\n @ETHTOOL_MM_VERIFY_STATUS_FAILED:\n\tthe Verify State diagram is in the state VERIFY_FAIL\n @ETHTOOL_MM_VERIFY_STATUS_DISABLED:\n\tverification of preemption operation is disabled"]
pub type ethtool_mm_verify_status = ::std::os::raw::c_uint;
#[doc = " struct ethtool_gstrings - string set for data tagging\n @cmd: Command number = %ETHTOOL_GSTRINGS\n @string_set: String set ID; one of &enum ethtool_stringset\n @len: On return, the number of strings in the string set\n @data: Buffer for strings.  Each string is null-padded to a size of\n\t%ETH_GSTRING_LEN.\n\n Users must use %ETHTOOL_GSSET_INFO to find the number of strings in\n the string set.  They must allocate a buffer of the appropriate\n size immediately following this structure."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_gstrings {
    pub cmd: __u32,
    pub string_set: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_ethtool_gstrings() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_gstrings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_gstrings>(),
        12usize,
        concat!("Size of: ", stringify!(ethtool_gstrings))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_gstrings>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_gstrings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_gstrings),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string_set) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_gstrings),
            "::",
            stringify!(string_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_gstrings),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_gstrings),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_sset_info - string set information\n @cmd: Command number = %ETHTOOL_GSSET_INFO\n @reserved: Reserved for future use; see the note on reserved space.\n @sset_mask: On entry, a bitmask of string sets to query, with bits\n\tnumbered according to &enum ethtool_stringset.  On return, a\n\tbitmask of those string sets queried that are supported.\n @data: Buffer for string set sizes.  On return, this contains the\n\tsize of each string set that was queried and supported, in\n\torder of ID.\n\n Example: The user passes in @sset_mask = 0x7 (sets 0, 1, 2) and on\n return @sset_mask == 0x6 (sets 1, 2).  Then @data[0] contains the\n size of set 1 and @data[1] contains the size of set 2.\n\n Users must allocate a buffer of the appropriate size (4 * number of\n sets queried) immediately following this structure."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_sset_info {
    pub cmd: __u32,
    pub reserved: __u32,
    pub sset_mask: __u64,
    pub data: __IncompleteArrayField<__u32>,
}
#[test]
fn bindgen_test_layout_ethtool_sset_info() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_sset_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_sset_info>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_sset_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_sset_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_sset_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_sset_info),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_sset_info),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sset_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_sset_info),
            "::",
            stringify!(sset_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_sset_info),
            "::",
            stringify!(data)
        )
    );
}
pub const ethtool_test_flags_ETH_TEST_FL_OFFLINE: ethtool_test_flags = 1;
pub const ethtool_test_flags_ETH_TEST_FL_FAILED: ethtool_test_flags = 2;
pub const ethtool_test_flags_ETH_TEST_FL_EXTERNAL_LB: ethtool_test_flags = 4;
pub const ethtool_test_flags_ETH_TEST_FL_EXTERNAL_LB_DONE: ethtool_test_flags = 8;
#[doc = " enum ethtool_test_flags - flags definition of ethtool_test\n @ETH_TEST_FL_OFFLINE: if set perform online and offline tests, otherwise\n\tonly online tests.\n @ETH_TEST_FL_FAILED: Driver set this flag if test fails.\n @ETH_TEST_FL_EXTERNAL_LB: Application request to perform external loopback\n\ttest.\n @ETH_TEST_FL_EXTERNAL_LB_DONE: Driver performed the external loopback test"]
pub type ethtool_test_flags = ::std::os::raw::c_uint;
#[doc = " struct ethtool_test - device self-test invocation\n @cmd: Command number = %ETHTOOL_TEST\n @flags: A bitmask of flags from &enum ethtool_test_flags.  Some\n\tflags may be set by the user on entry; others may be set by\n\tthe driver on return.\n @reserved: Reserved for future use; see the note on reserved space.\n @len: On return, the number of test results\n @data: Array of test results\n\n Users must use %ETHTOOL_GSSET_INFO or %ETHTOOL_GDRVINFO to find the\n number of test results that will be returned.  They must allocate a\n buffer of the appropriate size (8 * number of results) immediately\n following this structure."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_test {
    pub cmd: __u32,
    pub flags: __u32,
    pub reserved: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_ethtool_test() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_test> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_test>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_test))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_test>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_test))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_test),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_stats - device-specific statistics\n @cmd: Command number = %ETHTOOL_GSTATS\n @n_stats: On return, the number of statistics\n @data: Array of statistics\n\n Users must use %ETHTOOL_GSSET_INFO or %ETHTOOL_GDRVINFO to find the\n number of statistics that will be returned.  They must allocate a\n buffer of the appropriate size (8 * number of statistics)\n immediately following this structure."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_stats {
    pub cmd: __u32,
    pub n_stats: __u32,
    pub data: __IncompleteArrayField<__u64>,
}
#[test]
fn bindgen_test_layout_ethtool_stats() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_stats> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_stats>(),
        8usize,
        concat!("Size of: ", stringify!(ethtool_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_stats))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_stats),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_stats) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_stats),
            "::",
            stringify!(n_stats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_stats),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_perm_addr - permanent hardware address\n @cmd: Command number = %ETHTOOL_GPERMADDR\n @size: On entry, the size of the buffer.  On return, the size of the\n\taddress.  The command fails if the buffer is too small.\n @data: Buffer for the address\n\n Users must allocate the buffer immediately following this structure.\n A buffer size of %MAX_ADDR_LEN should be sufficient for any address\n type."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_perm_addr {
    pub cmd: __u32,
    pub size: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_ethtool_perm_addr() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_perm_addr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_perm_addr>(),
        8usize,
        concat!("Size of: ", stringify!(ethtool_perm_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_perm_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_perm_addr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_perm_addr),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_perm_addr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_perm_addr),
            "::",
            stringify!(data)
        )
    );
}
pub const ethtool_flags_ETH_FLAG_TXVLAN: ethtool_flags = 128;
pub const ethtool_flags_ETH_FLAG_RXVLAN: ethtool_flags = 256;
pub const ethtool_flags_ETH_FLAG_LRO: ethtool_flags = 32768;
pub const ethtool_flags_ETH_FLAG_NTUPLE: ethtool_flags = 134217728;
pub const ethtool_flags_ETH_FLAG_RXHASH: ethtool_flags = 268435456;
pub type ethtool_flags = ::std::os::raw::c_uint;
#[doc = " struct ethtool_tcpip4_spec - flow specification for TCP/IPv4 etc.\n @ip4src: Source host\n @ip4dst: Destination host\n @psrc: Source port\n @pdst: Destination port\n @tos: Type-of-service\n\n This can be used to specify a TCP/IPv4, UDP/IPv4 or SCTP/IPv4 flow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_tcpip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub psrc: __be16,
    pub pdst: __be16,
    pub tos: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_tcpip4_spec() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_tcpip4_spec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_tcpip4_spec>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_tcpip4_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_tcpip4_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_tcpip4_spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip4src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(ip4src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip4dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(ip4dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psrc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(psrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdst) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(pdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tos) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip4_spec),
            "::",
            stringify!(tos)
        )
    );
}
#[doc = " struct ethtool_ah_espip4_spec - flow specification for IPsec/IPv4\n @ip4src: Source host\n @ip4dst: Destination host\n @spi: Security parameters index\n @tos: Type-of-service\n\n This can be used to specify an IPsec transport or tunnel over IPv4."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ah_espip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub spi: __be32,
    pub tos: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_ah_espip4_spec() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_ah_espip4_spec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_ah_espip4_spec>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_ah_espip4_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_ah_espip4_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_ah_espip4_spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip4src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip4_spec),
            "::",
            stringify!(ip4src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip4dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip4_spec),
            "::",
            stringify!(ip4dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip4_spec),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tos) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip4_spec),
            "::",
            stringify!(tos)
        )
    );
}
#[doc = " struct ethtool_usrip4_spec - general flow specification for IPv4\n @ip4src: Source host\n @ip4dst: Destination host\n @l4_4_bytes: First 4 bytes of transport (layer 4) header\n @tos: Type-of-service\n @ip_ver: Value must be %ETH_RX_NFC_IP4; mask must be 0\n @proto: Transport protocol number; mask must be 0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_usrip4_spec {
    pub ip4src: __be32,
    pub ip4dst: __be32,
    pub l4_4_bytes: __be32,
    pub tos: __u8,
    pub ip_ver: __u8,
    pub proto: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_usrip4_spec() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_usrip4_spec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_usrip4_spec>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_usrip4_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_usrip4_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_usrip4_spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip4src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(ip4src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip4dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(ip4dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l4_4_bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(l4_4_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tos) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_ver) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(ip_ver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proto) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip4_spec),
            "::",
            stringify!(proto)
        )
    );
}
#[doc = " struct ethtool_tcpip6_spec - flow specification for TCP/IPv6 etc.\n @ip6src: Source host\n @ip6dst: Destination host\n @psrc: Source port\n @pdst: Destination port\n @tclass: Traffic Class\n\n This can be used to specify a TCP/IPv6, UDP/IPv6 or SCTP/IPv6 flow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_tcpip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub psrc: __be16,
    pub pdst: __be16,
    pub tclass: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_tcpip6_spec() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_tcpip6_spec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_tcpip6_spec>(),
        40usize,
        concat!("Size of: ", stringify!(ethtool_tcpip6_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_tcpip6_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_tcpip6_spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(ip6src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6dst) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(ip6dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).psrc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(psrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdst) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(pdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tclass) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_tcpip6_spec),
            "::",
            stringify!(tclass)
        )
    );
}
#[doc = " struct ethtool_ah_espip6_spec - flow specification for IPsec/IPv6\n @ip6src: Source host\n @ip6dst: Destination host\n @spi: Security parameters index\n @tclass: Traffic Class\n\n This can be used to specify an IPsec transport or tunnel over IPv6."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ah_espip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub spi: __be32,
    pub tclass: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_ah_espip6_spec() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_ah_espip6_spec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_ah_espip6_spec>(),
        40usize,
        concat!("Size of: ", stringify!(ethtool_ah_espip6_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_ah_espip6_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_ah_espip6_spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip6_spec),
            "::",
            stringify!(ip6src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6dst) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip6_spec),
            "::",
            stringify!(ip6dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spi) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip6_spec),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tclass) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ah_espip6_spec),
            "::",
            stringify!(tclass)
        )
    );
}
#[doc = " struct ethtool_usrip6_spec - general flow specification for IPv6\n @ip6src: Source host\n @ip6dst: Destination host\n @l4_4_bytes: First 4 bytes of transport (layer 4) header\n @tclass: Traffic Class\n @l4_proto: Transport protocol number (nexthdr after any Extension Headers)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_usrip6_spec {
    pub ip6src: [__be32; 4usize],
    pub ip6dst: [__be32; 4usize],
    pub l4_4_bytes: __be32,
    pub tclass: __u8,
    pub l4_proto: __u8,
}
#[test]
fn bindgen_test_layout_ethtool_usrip6_spec() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_usrip6_spec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_usrip6_spec>(),
        40usize,
        concat!("Size of: ", stringify!(ethtool_usrip6_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_usrip6_spec>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_usrip6_spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(ip6src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip6dst) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(ip6dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l4_4_bytes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(l4_4_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tclass) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(tclass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).l4_proto) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_usrip6_spec),
            "::",
            stringify!(l4_proto)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_flow_union {
    pub tcp_ip4_spec: ethtool_tcpip4_spec,
    pub udp_ip4_spec: ethtool_tcpip4_spec,
    pub sctp_ip4_spec: ethtool_tcpip4_spec,
    pub ah_ip4_spec: ethtool_ah_espip4_spec,
    pub esp_ip4_spec: ethtool_ah_espip4_spec,
    pub usr_ip4_spec: ethtool_usrip4_spec,
    pub tcp_ip6_spec: ethtool_tcpip6_spec,
    pub udp_ip6_spec: ethtool_tcpip6_spec,
    pub sctp_ip6_spec: ethtool_tcpip6_spec,
    pub ah_ip6_spec: ethtool_ah_espip6_spec,
    pub esp_ip6_spec: ethtool_ah_espip6_spec,
    pub usr_ip6_spec: ethtool_usrip6_spec,
    pub ether_spec: ethhdr,
    pub hdata: [__u8; 52usize],
}
#[test]
fn bindgen_test_layout_ethtool_flow_union() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_flow_union> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_flow_union>(),
        52usize,
        concat!("Size of: ", stringify!(ethtool_flow_union))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_flow_union>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_flow_union))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcp_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(tcp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udp_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(udp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sctp_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(sctp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ah_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(ah_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esp_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(esp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usr_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(usr_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcp_ip6_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(tcp_ip6_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udp_ip6_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(udp_ip6_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sctp_ip6_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(sctp_ip6_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ah_ip6_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(ah_ip6_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esp_ip6_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(esp_ip6_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usr_ip6_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(usr_ip6_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ether_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(ether_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_union),
            "::",
            stringify!(hdata)
        )
    );
}
#[doc = " struct ethtool_flow_ext - additional RX flow fields\n @h_dest: destination MAC address\n @vlan_etype: VLAN EtherType\n @vlan_tci: VLAN tag control information\n @data: user defined data\n @padding: Reserved for future use; see the note on reserved space.\n\n Note, @vlan_etype, @vlan_tci, and @data are only valid if %FLOW_EXT\n is set in &struct ethtool_rx_flow_spec @flow_type.\n @h_dest is valid if %FLOW_MAC_EXT is set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_flow_ext {
    pub padding: [__u8; 2usize],
    pub h_dest: [::std::os::raw::c_uchar; 6usize],
    pub vlan_etype: __be16,
    pub vlan_tci: __be16,
    pub data: [__be32; 2usize],
}
#[test]
fn bindgen_test_layout_ethtool_flow_ext() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_flow_ext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_flow_ext>(),
        20usize,
        concat!("Size of: ", stringify!(ethtool_flow_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_flow_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_flow_ext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_dest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(h_dest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_etype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(vlan_etype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_tci) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(vlan_tci)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flow_ext),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_rx_flow_spec - classification rule for RX flows\n @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW\n @h_u: Flow fields to match (dependent on @flow_type)\n @h_ext: Additional fields to match\n @m_u: Masks for flow field bits to be matched\n @m_ext: Masks for additional field bits to be matched\n\tNote, all additional fields must be ignored unless @flow_type\n\tincludes the %FLOW_EXT or %FLOW_MAC_EXT flag\n\t(see &struct ethtool_flow_ext description).\n @ring_cookie: RX ring/queue index to deliver to, or %RX_CLS_FLOW_DISC\n\tif packets should be discarded, or %RX_CLS_FLOW_WAKE if the\n\tpackets should be used for Wake-on-LAN with %WAKE_FILTER\n @location: Location of rule in the table.  Locations must be\n\tnumbered such that a flow matching multiple rules will be\n\tclassified according to the first (lowest numbered) rule."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_flow_spec {
    pub flow_type: __u32,
    pub h_u: ethtool_flow_union,
    pub h_ext: ethtool_flow_ext,
    pub m_u: ethtool_flow_union,
    pub m_ext: ethtool_flow_ext,
    pub ring_cookie: __u64,
    pub location: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_rx_flow_spec() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_rx_flow_spec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_rx_flow_spec>(),
        168usize,
        concat!("Size of: ", stringify!(ethtool_rx_flow_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_rx_flow_spec>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_rx_flow_spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_u) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(h_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_ext) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(h_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_u) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(m_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ext) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(m_ext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_cookie) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(ring_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_flow_spec),
            "::",
            stringify!(location)
        )
    );
}
#[doc = " struct ethtool_rxnfc - command to get or set RX flow classification rules\n @cmd: Specific command number - %ETHTOOL_GRXFH, %ETHTOOL_SRXFH,\n\t%ETHTOOL_GRXRINGS, %ETHTOOL_GRXCLSRLCNT, %ETHTOOL_GRXCLSRULE,\n\t%ETHTOOL_GRXCLSRLALL, %ETHTOOL_SRXCLSRLDEL or %ETHTOOL_SRXCLSRLINS\n @flow_type: Type of flow to be affected, e.g. %TCP_V4_FLOW\n @data: Command-dependent value\n @fs: Flow classification rule\n @rss_context: RSS context to be affected\n @rule_cnt: Number of rules to be affected\n @rule_locs: Array of used rule locations\n\n For %ETHTOOL_GRXFH and %ETHTOOL_SRXFH, @data is a bitmask indicating\n the fields included in the flow hash, e.g. %RXH_IP_SRC.  The following\n structure fields must not be used, except that if @flow_type includes\n the %FLOW_RSS flag, then @rss_context determines which RSS context to\n act on.\n\n For %ETHTOOL_GRXRINGS, @data is set to the number of RX rings/queues\n on return.\n\n For %ETHTOOL_GRXCLSRLCNT, @rule_cnt is set to the number of defined\n rules on return.  If @data is non-zero on return then it is the\n size of the rule table, plus the flag %RX_CLS_LOC_SPECIAL if the\n driver supports any special location values.  If that flag is not\n set in @data then special location values should not be used.\n\n For %ETHTOOL_GRXCLSRULE, @fs.@location specifies the location of an\n existing rule on entry and @fs contains the rule on return; if\n @fs.@flow_type includes the %FLOW_RSS flag, then @rss_context is\n filled with the RSS context ID associated with the rule.\n\n For %ETHTOOL_GRXCLSRLALL, @rule_cnt specifies the array size of the\n user buffer for @rule_locs on entry.  On return, @data is the size\n of the rule table, @rule_cnt is the number of defined rules, and\n @rule_locs contains the locations of the defined rules.  Drivers\n must use the second parameter to get_rxnfc() instead of @rule_locs.\n\n For %ETHTOOL_SRXCLSRLINS, @fs specifies the rule to add or update.\n @fs.@location either specifies the location to use or is a special\n location value with %RX_CLS_LOC_SPECIAL flag set.  On return,\n @fs.@location is the actual rule location.  If @fs.@flow_type\n includes the %FLOW_RSS flag, @rss_context is the RSS context ID to\n use for flow spreading traffic which matches this rule.  The value\n from the rxfh indirection table will be added to @fs.@ring_cookie\n to choose which ring to deliver to.\n\n For %ETHTOOL_SRXCLSRLDEL, @fs.@location specifies the location of an\n existing rule on entry.\n\n A driver supporting the special location values for\n %ETHTOOL_SRXCLSRLINS may add the rule at any suitable unused\n location, and may remove a rule at a later location (lower\n priority) that matches exactly the same set of flows.  The special\n values are %RX_CLS_LOC_ANY, selecting any location;\n %RX_CLS_LOC_FIRST, selecting the first suitable location (maximum\n priority); and %RX_CLS_LOC_LAST, selecting the last suitable\n location (minimum priority).  Additional special values may be\n defined in future and drivers must return -%EINVAL for any\n unrecognised value."]
#[repr(C)]
pub struct ethtool_rxnfc {
    pub cmd: __u32,
    pub flow_type: __u32,
    pub data: __u64,
    pub fs: ethtool_rx_flow_spec,
    pub __bindgen_anon_1: ethtool_rxnfc__bindgen_ty_1,
    pub rule_locs: __IncompleteArrayField<__u32>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rxnfc__bindgen_ty_1 {
    pub rule_cnt: __u32,
    pub rss_context: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_rxnfc__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_rxnfc__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_rxnfc__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ethtool_rxnfc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_rxnfc__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_rxnfc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rule_cnt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc__bindgen_ty_1),
            "::",
            stringify!(rule_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss_context) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc__bindgen_ty_1),
            "::",
            stringify!(rss_context)
        )
    );
}
#[test]
fn bindgen_test_layout_ethtool_rxnfc() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_rxnfc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_rxnfc>(),
        192usize,
        concat!("Size of: ", stringify!(ethtool_rxnfc))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_rxnfc>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_rxnfc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rule_locs) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxnfc),
            "::",
            stringify!(rule_locs)
        )
    );
}
#[doc = " struct ethtool_rxfh_indir - command to get or set RX flow hash indirection\n @cmd: Specific command number - %ETHTOOL_GRXFHINDIR or %ETHTOOL_SRXFHINDIR\n @size: On entry, the array size of the user buffer, which may be zero.\n\tOn return from %ETHTOOL_GRXFHINDIR, the array size of the hardware\n\tindirection table.\n @ring_index: RX ring/queue index for each hash value\n\n For %ETHTOOL_GRXFHINDIR, a @size of zero means that only the size\n should be returned.  For %ETHTOOL_SRXFHINDIR, a @size of zero means\n the table should be reset to default values.  This last feature\n is not supported by the original implementations."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_rxfh_indir {
    pub cmd: __u32,
    pub size: __u32,
    pub ring_index: __IncompleteArrayField<__u32>,
}
#[test]
fn bindgen_test_layout_ethtool_rxfh_indir() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_rxfh_indir> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_rxfh_indir>(),
        8usize,
        concat!("Size of: ", stringify!(ethtool_rxfh_indir))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_rxfh_indir>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_rxfh_indir))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh_indir),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh_indir),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ring_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh_indir),
            "::",
            stringify!(ring_index)
        )
    );
}
#[doc = " struct ethtool_rxfh - command to get/set RX flow hash indir or/and hash key.\n @cmd: Specific command number - %ETHTOOL_GRSSH or %ETHTOOL_SRSSH\n @rss_context: RSS context identifier.  Context 0 is the default for normal\n\ttraffic; other contexts can be referenced as the destination for RX flow\n\tclassification rules.  %ETH_RXFH_CONTEXT_ALLOC is used with command\n\t%ETHTOOL_SRSSH to allocate a new RSS context; on return this field will\n\tcontain the ID of the newly allocated context.\n @indir_size: On entry, the array size of the user buffer for the\n\tindirection table, which may be zero, or (for %ETHTOOL_SRSSH),\n\t%ETH_RXFH_INDIR_NO_CHANGE.  On return from %ETHTOOL_GRSSH,\n\tthe array size of the hardware indirection table.\n @key_size: On entry, the array size of the user buffer for the hash key,\n\twhich may be zero.  On return from %ETHTOOL_GRSSH, the size of the\n\thardware hash key.\n @hfunc: Defines the current RSS hash function used by HW (or to be set to).\n\tValid values are one of the %ETH_RSS_HASH_*.\n @rsvd8: Reserved for future use; see the note on reserved space.\n @rsvd32: Reserved for future use; see the note on reserved space.\n @rss_config: RX ring/queue index for each hash value i.e., indirection table\n\tof @indir_size __u32 elements, followed by hash key of @key_size\n\tbytes.\n\n For %ETHTOOL_GRSSH, a @indir_size and key_size of zero means that only the\n size should be returned.  For %ETHTOOL_SRSSH, an @indir_size of\n %ETH_RXFH_INDIR_NO_CHANGE means that indir table setting is not requested\n and a @indir_size of zero means the indir table should be reset to default\n values (if @rss_context == 0) or that the RSS context should be deleted.\n An hfunc of zero means that hash function setting is not requested."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_rxfh {
    pub cmd: __u32,
    pub rss_context: __u32,
    pub indir_size: __u32,
    pub key_size: __u32,
    pub hfunc: __u8,
    pub rsvd8: [__u8; 3usize],
    pub rsvd32: __u32,
    pub rss_config: __IncompleteArrayField<__u32>,
}
#[test]
fn bindgen_test_layout_ethtool_rxfh() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_rxfh> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_rxfh>(),
        24usize,
        concat!("Size of: ", stringify!(ethtool_rxfh))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_rxfh>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_rxfh))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss_context) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh),
            "::",
            stringify!(rss_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indir_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh),
            "::",
            stringify!(indir_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh),
            "::",
            stringify!(key_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hfunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh),
            "::",
            stringify!(hfunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd8) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh),
            "::",
            stringify!(rsvd8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsvd32) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh),
            "::",
            stringify!(rsvd32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rss_config) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rxfh),
            "::",
            stringify!(rss_config)
        )
    );
}
#[doc = " struct ethtool_rx_ntuple_flow_spec - specification for RX flow filter\n @flow_type: Type of match to perform, e.g. %TCP_V4_FLOW\n @h_u: Flow field values to match (dependent on @flow_type)\n @m_u: Masks for flow field value bits to be ignored\n @vlan_tag: VLAN tag to match\n @vlan_tag_mask: Mask for VLAN tag bits to be ignored\n @data: Driver-dependent data to match\n @data_mask: Mask for driver-dependent data bits to be ignored\n @action: RX ring/queue index to deliver to (non-negative) or other action\n\t(negative, e.g. %ETHTOOL_RXNTUPLE_ACTION_DROP)\n\n For flow types %TCP_V4_FLOW, %UDP_V4_FLOW and %SCTP_V4_FLOW, where\n a field value and mask are both zero this is treated as if all mask\n bits are set i.e. the field is ignored."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_ntuple_flow_spec {
    pub flow_type: __u32,
    pub h_u: ethtool_rx_ntuple_flow_spec__bindgen_ty_1,
    pub m_u: ethtool_rx_ntuple_flow_spec__bindgen_ty_1,
    pub vlan_tag: __u16,
    pub vlan_tag_mask: __u16,
    pub data: __u64,
    pub data_mask: __u64,
    pub action: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ethtool_rx_ntuple_flow_spec__bindgen_ty_1 {
    pub tcp_ip4_spec: ethtool_tcpip4_spec,
    pub udp_ip4_spec: ethtool_tcpip4_spec,
    pub sctp_ip4_spec: ethtool_tcpip4_spec,
    pub ah_ip4_spec: ethtool_ah_espip4_spec,
    pub esp_ip4_spec: ethtool_ah_espip4_spec,
    pub usr_ip4_spec: ethtool_usrip4_spec,
    pub ether_spec: ethhdr,
    pub hdata: [__u8; 72usize],
}
#[test]
fn bindgen_test_layout_ethtool_rx_ntuple_flow_spec__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_rx_ntuple_flow_spec__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_rx_ntuple_flow_spec__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_rx_ntuple_flow_spec__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcp_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1),
            "::",
            stringify!(tcp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udp_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1),
            "::",
            stringify!(udp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sctp_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1),
            "::",
            stringify!(sctp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ah_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ah_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).esp_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1),
            "::",
            stringify!(esp_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usr_ip4_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1),
            "::",
            stringify!(usr_ip4_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ether_spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ether_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec__bindgen_ty_1),
            "::",
            stringify!(hdata)
        )
    );
}
#[test]
fn bindgen_test_layout_ethtool_rx_ntuple_flow_spec() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_rx_ntuple_flow_spec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_rx_ntuple_flow_spec>(),
        176usize,
        concat!("Size of: ", stringify!(ethtool_rx_ntuple_flow_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_rx_ntuple_flow_spec>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_rx_ntuple_flow_spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flow_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec),
            "::",
            stringify!(flow_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h_u) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec),
            "::",
            stringify!(h_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_u) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec),
            "::",
            stringify!(m_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_tag) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec),
            "::",
            stringify!(vlan_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlan_tag_mask) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec),
            "::",
            stringify!(vlan_tag_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_mask) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec),
            "::",
            stringify!(data_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple_flow_spec),
            "::",
            stringify!(action)
        )
    );
}
#[doc = " struct ethtool_rx_ntuple - command to set or clear RX flow filter\n @cmd: Command number - %ETHTOOL_SRXNTUPLE\n @fs: Flow filter specification"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_rx_ntuple {
    pub cmd: __u32,
    pub fs: ethtool_rx_ntuple_flow_spec,
}
#[test]
fn bindgen_test_layout_ethtool_rx_ntuple() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_rx_ntuple> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_rx_ntuple>(),
        184usize,
        concat!("Size of: ", stringify!(ethtool_rx_ntuple))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_rx_ntuple>(),
        8usize,
        concat!("Alignment of ", stringify!(ethtool_rx_ntuple))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_rx_ntuple),
            "::",
            stringify!(fs)
        )
    );
}
pub const ethtool_flash_op_type_ETHTOOL_FLASH_ALL_REGIONS: ethtool_flash_op_type = 0;
pub type ethtool_flash_op_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_flash {
    pub cmd: __u32,
    pub region: __u32,
    pub data: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_ethtool_flash() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_flash> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_flash>(),
        136usize,
        concat!("Size of: ", stringify!(ethtool_flash))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_flash>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_flash))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flash),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).region) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flash),
            "::",
            stringify!(region)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_flash),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_dump - used for retrieving, setting device dump\n @cmd: Command number - %ETHTOOL_GET_DUMP_FLAG, %ETHTOOL_GET_DUMP_DATA, or\n \t%ETHTOOL_SET_DUMP\n @version: FW version of the dump, filled in by driver\n @flag: driver dependent flag for dump setting, filled in by driver during\n        get and filled in by ethtool for set operation.\n        flag must be initialized by macro ETH_FW_DUMP_DISABLE value when\n        firmware dump is disabled.\n @len: length of dump data, used as the length of the user buffer on entry to\n \t %ETHTOOL_GET_DUMP_DATA and this is returned as dump length by driver\n \t for %ETHTOOL_GET_DUMP_FLAG command\n @data: data collected for get dump data operation"]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_dump {
    pub cmd: __u32,
    pub version: __u32,
    pub flag: __u32,
    pub len: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[test]
fn bindgen_test_layout_ethtool_dump() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_dump> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_dump>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_dump))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_dump>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_dump))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_dump),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_get_features_block - block with state of 32 features\n @available: mask of changeable features\n @requested: mask of features requested to be enabled if possible\n @active: mask of currently enabled features\n @never_changed: mask of features not changeable for any device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_get_features_block {
    pub available: __u32,
    pub requested: __u32,
    pub active: __u32,
    pub never_changed: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_get_features_block() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_get_features_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_get_features_block>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_get_features_block))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_get_features_block>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_get_features_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).available) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_get_features_block),
            "::",
            stringify!(available)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requested) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_get_features_block),
            "::",
            stringify!(requested)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_get_features_block),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).never_changed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_get_features_block),
            "::",
            stringify!(never_changed)
        )
    );
}
#[doc = " struct ethtool_gfeatures - command to get state of device's features\n @cmd: command number = %ETHTOOL_GFEATURES\n @size: On entry, the number of elements in the features[] array;\n\ton return, the number of elements in features[] needed to hold\n\tall features\n @features: state of features"]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_gfeatures {
    pub cmd: __u32,
    pub size: __u32,
    pub features: __IncompleteArrayField<ethtool_get_features_block>,
}
#[test]
fn bindgen_test_layout_ethtool_gfeatures() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_gfeatures> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_gfeatures>(),
        8usize,
        concat!("Size of: ", stringify!(ethtool_gfeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_gfeatures>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_gfeatures))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_gfeatures),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_gfeatures),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_gfeatures),
            "::",
            stringify!(features)
        )
    );
}
#[doc = " struct ethtool_set_features_block - block with request for 32 features\n @valid: mask of features to be changed\n @requested: values of features to be changed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_set_features_block {
    pub valid: __u32,
    pub requested: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_set_features_block() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_set_features_block> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_set_features_block>(),
        8usize,
        concat!("Size of: ", stringify!(ethtool_set_features_block))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_set_features_block>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_set_features_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_set_features_block),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requested) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_set_features_block),
            "::",
            stringify!(requested)
        )
    );
}
#[doc = " struct ethtool_sfeatures - command to request change in device's features\n @cmd: command number = %ETHTOOL_SFEATURES\n @size: array size of the features[] array\n @features: feature change masks"]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_sfeatures {
    pub cmd: __u32,
    pub size: __u32,
    pub features: __IncompleteArrayField<ethtool_set_features_block>,
}
#[test]
fn bindgen_test_layout_ethtool_sfeatures() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_sfeatures> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_sfeatures>(),
        8usize,
        concat!("Size of: ", stringify!(ethtool_sfeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_sfeatures>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_sfeatures))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_sfeatures),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_sfeatures),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_sfeatures),
            "::",
            stringify!(features)
        )
    );
}
#[doc = " struct ethtool_ts_info - holds a device's timestamping and PHC association\n @cmd: command number = %ETHTOOL_GET_TS_INFO\n @so_timestamping: bit mask of the sum of the supported SO_TIMESTAMPING flags\n @phc_index: device index of the associated PHC, or -1 if there is none\n @tx_types: bit mask of the supported hwtstamp_tx_types enumeration values\n @tx_reserved: Reserved for future use; see the note on reserved space.\n @rx_filters: bit mask of the supported hwtstamp_rx_filters enumeration values\n @rx_reserved: Reserved for future use; see the note on reserved space.\n\n The bits in the 'tx_types' and 'rx_filters' fields correspond to\n the 'hwtstamp_tx_types' and 'hwtstamp_rx_filters' enumeration values,\n respectively.  For example, if the device supports HWTSTAMP_TX_ON,\n then (1 << HWTSTAMP_TX_ON) in 'tx_types' will be set.\n\n Drivers should only report the filters they actually support without\n upscaling in the SIOCSHWTSTAMP ioctl. If the SIOCSHWSTAMP request for\n HWTSTAMP_FILTER_V1_SYNC is supported by HWTSTAMP_FILTER_V1_EVENT, then the\n driver should only report HWTSTAMP_FILTER_V1_EVENT in this op."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_ts_info {
    pub cmd: __u32,
    pub so_timestamping: __u32,
    pub phc_index: __s32,
    pub tx_types: __u32,
    pub tx_reserved: [__u32; 3usize],
    pub rx_filters: __u32,
    pub rx_reserved: [__u32; 3usize],
}
#[test]
fn bindgen_test_layout_ethtool_ts_info() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_ts_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_ts_info>(),
        44usize,
        concat!("Size of: ", stringify!(ethtool_ts_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_ts_info>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_ts_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).so_timestamping) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(so_timestamping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phc_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(phc_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_types) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(tx_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_reserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(tx_reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_filters) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(rx_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_reserved) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_ts_info),
            "::",
            stringify!(rx_reserved)
        )
    );
}
pub const ethtool_sfeatures_retval_bits_ETHTOOL_F_UNSUPPORTED__BIT: ethtool_sfeatures_retval_bits =
    0;
pub const ethtool_sfeatures_retval_bits_ETHTOOL_F_WISH__BIT: ethtool_sfeatures_retval_bits = 1;
pub const ethtool_sfeatures_retval_bits_ETHTOOL_F_COMPAT__BIT: ethtool_sfeatures_retval_bits = 2;
pub type ethtool_sfeatures_retval_bits = ::std::os::raw::c_uint;
#[doc = " struct ethtool_per_queue_op - apply sub command to the queues in mask.\n @cmd: ETHTOOL_PERQUEUE\n @sub_command: the sub command which apply to each queues\n @queue_mask: Bitmap of the queues which sub command apply to\n @data: A complete command structure following for each of the queues addressed"]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_per_queue_op {
    pub cmd: __u32,
    pub sub_command: __u32,
    pub queue_mask: [__u32; 128usize],
    pub data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_ethtool_per_queue_op() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_per_queue_op> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_per_queue_op>(),
        520usize,
        concat!("Size of: ", stringify!(ethtool_per_queue_op))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_per_queue_op>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_per_queue_op))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_per_queue_op),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_command) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_per_queue_op),
            "::",
            stringify!(sub_command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).queue_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_per_queue_op),
            "::",
            stringify!(queue_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_per_queue_op),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " struct ethtool_fecparam - Ethernet Forward Error Correction parameters\n @cmd: Command number = %ETHTOOL_GFECPARAM or %ETHTOOL_SFECPARAM\n @active_fec: FEC mode which is active on the port, single bit set, GET only.\n @fec: Bitmask of configured FEC modes.\n @reserved: Reserved for future extensions, ignore on GET, write 0 for SET.\n\n Note that @reserved was never validated on input and ethtool user space\n left it uninitialized when calling SET. Hence going forward it can only be\n used to return a value to userspace with GET.\n\n FEC modes supported by the device can be read via %ETHTOOL_GLINKSETTINGS.\n FEC settings are configured by link autonegotiation whenever it's enabled.\n With autoneg on %ETHTOOL_GFECPARAM can be used to read the current mode.\n\n When autoneg is disabled %ETHTOOL_SFECPARAM controls the FEC settings.\n It is recommended that drivers only accept a single bit set in @fec.\n When multiple bits are set in @fec drivers may pick mode in an implementation\n dependent way. Drivers should reject mixing %ETHTOOL_FEC_AUTO_BIT with other\n FEC modes, because it's unclear whether in this case other modes constrain\n AUTO or are independent choices.\n Drivers must reject SET requests if they support none of the requested modes.\n\n If device does not support FEC drivers may use %ETHTOOL_FEC_NONE instead\n of returning %EOPNOTSUPP from %ETHTOOL_GFECPARAM.\n\n See enum ethtool_fec_config_bits for definition of valid bits for both\n @fec and @active_fec."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ethtool_fecparam {
    pub cmd: __u32,
    pub active_fec: __u32,
    pub fec: __u32,
    pub reserved: __u32,
}
#[test]
fn bindgen_test_layout_ethtool_fecparam() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_fecparam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_fecparam>(),
        16usize,
        concat!("Size of: ", stringify!(ethtool_fecparam))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_fecparam>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_fecparam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_fecparam),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).active_fec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_fecparam),
            "::",
            stringify!(active_fec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_fecparam),
            "::",
            stringify!(fec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_fecparam),
            "::",
            stringify!(reserved)
        )
    );
}
pub const ethtool_fec_config_bits_ETHTOOL_FEC_NONE_BIT: ethtool_fec_config_bits = 0;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_AUTO_BIT: ethtool_fec_config_bits = 1;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_OFF_BIT: ethtool_fec_config_bits = 2;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_RS_BIT: ethtool_fec_config_bits = 3;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_BASER_BIT: ethtool_fec_config_bits = 4;
pub const ethtool_fec_config_bits_ETHTOOL_FEC_LLRS_BIT: ethtool_fec_config_bits = 5;
#[doc = " enum ethtool_fec_config_bits - flags definition of ethtool_fec_configuration\n @ETHTOOL_FEC_NONE_BIT: FEC mode configuration is not supported. Should not\n\t\t\tbe used together with other bits. GET only.\n @ETHTOOL_FEC_AUTO_BIT: Select default/best FEC mode automatically, usually\n\t\t\tbased link mode and SFP parameters read from module's\n\t\t\tEEPROM. This bit does _not_ mean autonegotiation.\n @ETHTOOL_FEC_OFF_BIT: No FEC Mode\n @ETHTOOL_FEC_RS_BIT: Reed-Solomon FEC Mode\n @ETHTOOL_FEC_BASER_BIT: Base-R/Reed-Solomon FEC Mode\n @ETHTOOL_FEC_LLRS_BIT: Low Latency Reed Solomon FEC Mode (25G/50G Ethernet\n\t\t\tConsortium)"]
pub type ethtool_fec_config_bits = ::std::os::raw::c_uint;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT_Half_BIT:
    ethtool_link_mode_bit_indices = 0;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 1;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseT_Half_BIT:
    ethtool_link_mode_bit_indices = 2;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 3;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseT_Half_BIT:
    ethtool_link_mode_bit_indices = 4;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 5;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Autoneg_BIT:
    ethtool_link_mode_bit_indices = 6;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_TP_BIT: ethtool_link_mode_bit_indices = 7;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_AUI_BIT: ethtool_link_mode_bit_indices =
    8;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_MII_BIT: ethtool_link_mode_bit_indices =
    9;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FIBRE_BIT: ethtool_link_mode_bit_indices =
    10;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_BNC_BIT: ethtool_link_mode_bit_indices =
    11;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 12;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Pause_BIT: ethtool_link_mode_bit_indices =
    13;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Asym_Pause_BIT:
    ethtool_link_mode_bit_indices = 14;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_2500baseX_Full_BIT:
    ethtool_link_mode_bit_indices = 15;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_Backplane_BIT:
    ethtool_link_mode_bit_indices = 16;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseKX_Full_BIT:
    ethtool_link_mode_bit_indices = 17;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT:
    ethtool_link_mode_bit_indices = 18;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 19;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseR_FEC_BIT:
    ethtool_link_mode_bit_indices = 20;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT:
    ethtool_link_mode_bit_indices = 21;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 22;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 23;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 24;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 25;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT:
    ethtool_link_mode_bit_indices = 26;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 27;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 28;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 29;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT:
    ethtool_link_mode_bit_indices = 30;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_25000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 31;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_25000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 32;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_25000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 33;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 34;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 35;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 36;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 37;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 38;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT:
    ethtool_link_mode_bit_indices = 39;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 40;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseX_Full_BIT:
    ethtool_link_mode_bit_indices = 41;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 42;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 43;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseLR_Full_BIT:
    ethtool_link_mode_bit_indices = 44;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT:
    ethtool_link_mode_bit_indices = 45;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10000baseER_Full_BIT:
    ethtool_link_mode_bit_indices = 46;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_2500baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 47;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_5000baseT_Full_BIT:
    ethtool_link_mode_bit_indices = 48;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_NONE_BIT:
    ethtool_link_mode_bit_indices = 49;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_RS_BIT:
    ethtool_link_mode_bit_indices = 50;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_BASER_BIT:
    ethtool_link_mode_bit_indices = 51;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 52;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 53;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 54;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT:
    ethtool_link_mode_bit_indices = 55;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_50000baseDR_Full_BIT:
    ethtool_link_mode_bit_indices = 56;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 57;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 58;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 59;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT:
    ethtool_link_mode_bit_indices = 60;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT:
    ethtool_link_mode_bit_indices = 61;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 62;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 63;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT:
    ethtool_link_mode_bit_indices = 64;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT:
    ethtool_link_mode_bit_indices = 65;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 66;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseT1_Full_BIT:
    ethtool_link_mode_bit_indices = 67;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_1000baseT1_Full_BIT:
    ethtool_link_mode_bit_indices = 68;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT:
    ethtool_link_mode_bit_indices = 69;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT:
    ethtool_link_mode_bit_indices = 70;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT:
    ethtool_link_mode_bit_indices = 71;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT:
    ethtool_link_mode_bit_indices = 72;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT:
    ethtool_link_mode_bit_indices = 73;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_FEC_LLRS_BIT:
    ethtool_link_mode_bit_indices = 74;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseKR_Full_BIT:
    ethtool_link_mode_bit_indices = 75;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseSR_Full_BIT:
    ethtool_link_mode_bit_indices = 76;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT:
    ethtool_link_mode_bit_indices = 77;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseCR_Full_BIT:
    ethtool_link_mode_bit_indices = 78;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100000baseDR_Full_BIT:
    ethtool_link_mode_bit_indices = 79;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT:
    ethtool_link_mode_bit_indices = 80;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT:
    ethtool_link_mode_bit_indices = 81;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT:
    ethtool_link_mode_bit_indices = 82;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT:
    ethtool_link_mode_bit_indices = 83;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT:
    ethtool_link_mode_bit_indices = 84;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT:
    ethtool_link_mode_bit_indices = 85;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT:
    ethtool_link_mode_bit_indices = 86;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT:
    ethtool_link_mode_bit_indices = 87;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT:
    ethtool_link_mode_bit_indices = 88;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT:
    ethtool_link_mode_bit_indices = 89;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseFX_Half_BIT:
    ethtool_link_mode_bit_indices = 90;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_100baseFX_Full_BIT:
    ethtool_link_mode_bit_indices = 91;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1L_Full_BIT:
    ethtool_link_mode_bit_indices = 92;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseCR8_Full_BIT:
    ethtool_link_mode_bit_indices = 93;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseKR8_Full_BIT:
    ethtool_link_mode_bit_indices = 94;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseDR8_Full_BIT:
    ethtool_link_mode_bit_indices = 95;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseDR8_2_Full_BIT:
    ethtool_link_mode_bit_indices = 96;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseSR8_Full_BIT:
    ethtool_link_mode_bit_indices = 97;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_800000baseVR8_Full_BIT:
    ethtool_link_mode_bit_indices = 98;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1S_Full_BIT:
    ethtool_link_mode_bit_indices = 99;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1S_Half_BIT:
    ethtool_link_mode_bit_indices = 100;
pub const ethtool_link_mode_bit_indices_ETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT:
    ethtool_link_mode_bit_indices = 101;
pub const ethtool_link_mode_bit_indices___ETHTOOL_LINK_MODE_MASK_NBITS:
    ethtool_link_mode_bit_indices = 102;
pub type ethtool_link_mode_bit_indices = ::std::os::raw::c_uint;
pub const ethtool_reset_flags_ETH_RESET_MGMT: ethtool_reset_flags = 1;
pub const ethtool_reset_flags_ETH_RESET_IRQ: ethtool_reset_flags = 2;
pub const ethtool_reset_flags_ETH_RESET_DMA: ethtool_reset_flags = 4;
pub const ethtool_reset_flags_ETH_RESET_FILTER: ethtool_reset_flags = 8;
pub const ethtool_reset_flags_ETH_RESET_OFFLOAD: ethtool_reset_flags = 16;
pub const ethtool_reset_flags_ETH_RESET_MAC: ethtool_reset_flags = 32;
pub const ethtool_reset_flags_ETH_RESET_PHY: ethtool_reset_flags = 64;
pub const ethtool_reset_flags_ETH_RESET_RAM: ethtool_reset_flags = 128;
pub const ethtool_reset_flags_ETH_RESET_AP: ethtool_reset_flags = 256;
pub const ethtool_reset_flags_ETH_RESET_DEDICATED: ethtool_reset_flags = 65535;
pub const ethtool_reset_flags_ETH_RESET_ALL: ethtool_reset_flags = 4294967295;
pub type ethtool_reset_flags = ::std::os::raw::c_uint;
#[doc = " struct ethtool_link_settings - link control and status\n\n IMPORTANT, Backward compatibility notice: When implementing new\n\tuser-space tools, please first try %ETHTOOL_GLINKSETTINGS, and\n\tif it succeeds use %ETHTOOL_SLINKSETTINGS to change link\n\tsettings; do not use %ETHTOOL_SSET if %ETHTOOL_GLINKSETTINGS\n\tsucceeded: stick to %ETHTOOL_GLINKSETTINGS/%SLINKSETTINGS in\n\tthat case.  Conversely, if %ETHTOOL_GLINKSETTINGS fails, use\n\t%ETHTOOL_GSET to query and %ETHTOOL_SSET to change link\n\tsettings; do not use %ETHTOOL_SLINKSETTINGS if\n\t%ETHTOOL_GLINKSETTINGS failed: stick to\n\t%ETHTOOL_GSET/%ETHTOOL_SSET in that case.\n\n @cmd: Command number = %ETHTOOL_GLINKSETTINGS or %ETHTOOL_SLINKSETTINGS\n @speed: Link speed (Mbps)\n @duplex: Duplex mode; one of %DUPLEX_*\n @port: Physical connector type; one of %PORT_*\n @phy_address: MDIO address of PHY (transceiver); 0 or 255 if not\n\tapplicable.  For clause 45 PHYs this is the PRTAD.\n @autoneg: Enable/disable autonegotiation and auto-detection;\n\teither %AUTONEG_DISABLE or %AUTONEG_ENABLE\n @mdio_support: Bitmask of %ETH_MDIO_SUPPORTS_* flags for the MDIO\n\tprotocols supported by the interface; 0 if unknown.\n\tRead-only.\n @eth_tp_mdix: Ethernet twisted-pair MDI(-X) status; one of\n\t%ETH_TP_MDI_*.  If the status is unknown or not applicable, the\n\tvalue will be %ETH_TP_MDI_INVALID.  Read-only.\n @eth_tp_mdix_ctrl: Ethernet twisted pair MDI(-X) control; one of\n\t%ETH_TP_MDI_*.  If MDI(-X) control is not implemented, reads\n\tyield %ETH_TP_MDI_INVALID and writes may be ignored or rejected.\n\tWhen written successfully, the link should be renegotiated if\n\tnecessary.\n @link_mode_masks_nwords: Number of 32-bit words for each of the\n\tsupported, advertising, lp_advertising link mode bitmaps. For\n\t%ETHTOOL_GLINKSETTINGS: on entry, number of words passed by user\n\t(>= 0); on return, if handshake in progress, negative if\n\trequest size unsupported by kernel: absolute value indicates\n\tkernel expected size and all the other fields but cmd\n\tare 0; otherwise (handshake completed), strictly positive\n\tto indicate size used by kernel and cmd field stays\n\t%ETHTOOL_GLINKSETTINGS, all other fields populated by driver. For\n\t%ETHTOOL_SLINKSETTINGS: must be valid on entry, ie. a positive\n\tvalue returned previously by %ETHTOOL_GLINKSETTINGS, otherwise\n\trefused. For drivers: ignore this field (use kernel's\n\t__ETHTOOL_LINK_MODE_MASK_NBITS instead), any change to it will\n\tbe overwritten by kernel.\n @supported: Bitmap with each bit meaning given by\n\t%ethtool_link_mode_bit_indices for the link modes, physical\n\tconnectors and other link features for which the interface\n\tsupports autonegotiation or auto-detection.  Read-only.\n @advertising: Bitmap with each bit meaning given by\n\t%ethtool_link_mode_bit_indices for the link modes, physical\n\tconnectors and other link features that are advertised through\n\tautonegotiation or enabled for auto-detection.\n @lp_advertising: Bitmap with each bit meaning given by\n\t%ethtool_link_mode_bit_indices for the link modes, and other\n\tlink features that the link partner advertised through\n\tautonegotiation; 0 if unknown or not applicable.  Read-only.\n @transceiver: Used to distinguish different possible PHY types,\n\treported consistently by PHYLIB.  Read-only.\n @master_slave_cfg: Master/slave port mode.\n @master_slave_state: Master/slave port state.\n @rate_matching: Rate adaptation performed by the PHY\n @reserved: Reserved for future use; see the note on reserved space.\n @link_mode_masks: Variable length bitmaps.\n\n If autonegotiation is disabled, the speed and @duplex represent the\n fixed link mode and are writable if the driver supports multiple\n link modes.  If it is enabled then they are read-only; if the link\n is up they represent the negotiated link mode; if the link is down,\n the speed is 0, %SPEED_UNKNOWN or the highest enabled speed and\n @duplex is %DUPLEX_UNKNOWN or the best enabled duplex mode.\n\n Some hardware interfaces may have multiple PHYs and/or physical\n connectors fitted or do not allow the driver to detect which are\n fitted.  For these interfaces @port and/or @phy_address may be\n writable, possibly dependent on @autoneg being %AUTONEG_DISABLE.\n Otherwise, attempts to write different values may be ignored or\n rejected.\n\n Deprecated %ethtool_cmd fields transceiver, maxtxpkt and maxrxpkt\n are not available in %ethtool_link_settings. These fields will be\n always set to zero in %ETHTOOL_GSET reply and %ETHTOOL_SSET will\n fail if any of them is set to non-zero value.\n\n Users should assume that all fields not marked read-only are\n writable and subject to validation by the driver.  They should use\n %ETHTOOL_GLINKSETTINGS to get the current values before making specific\n changes and then applying them with %ETHTOOL_SLINKSETTINGS.\n\n Drivers that implement %get_link_ksettings and/or\n %set_link_ksettings should ignore the @cmd\n and @link_mode_masks_nwords fields (any change to them overwritten\n by kernel), and rely only on kernel's internal\n %__ETHTOOL_LINK_MODE_MASK_NBITS and\n %ethtool_link_mode_mask_t. Drivers that implement\n %set_link_ksettings() should validate all fields other than @cmd\n and @link_mode_masks_nwords that are not described as read-only or\n deprecated, and must ignore all fields described as read-only."]
#[repr(C)]
#[derive(Debug)]
pub struct ethtool_link_settings {
    pub cmd: __u32,
    pub speed: __u32,
    pub duplex: __u8,
    pub port: __u8,
    pub phy_address: __u8,
    pub autoneg: __u8,
    pub mdio_support: __u8,
    pub eth_tp_mdix: __u8,
    pub eth_tp_mdix_ctrl: __u8,
    pub link_mode_masks_nwords: __s8,
    pub transceiver: __u8,
    pub master_slave_cfg: __u8,
    pub master_slave_state: __u8,
    pub rate_matching: __u8,
    pub reserved: [__u32; 7usize],
    pub link_mode_masks: __IncompleteArrayField<__u32>,
}
#[test]
fn bindgen_test_layout_ethtool_link_settings() {
    const UNINIT: ::std::mem::MaybeUninit<ethtool_link_settings> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ethtool_link_settings>(),
        48usize,
        concat!("Size of: ", stringify!(ethtool_link_settings))
    );
    assert_eq!(
        ::std::mem::align_of::<ethtool_link_settings>(),
        4usize,
        concat!("Alignment of ", stringify!(ethtool_link_settings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duplex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(duplex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phy_address) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(phy_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autoneg) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(autoneg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mdio_support) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(mdio_support)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eth_tp_mdix) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(eth_tp_mdix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eth_tp_mdix_ctrl) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(eth_tp_mdix_ctrl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_mode_masks_nwords) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(link_mode_masks_nwords)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transceiver) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(transceiver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).master_slave_cfg) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(master_slave_cfg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).master_slave_state) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(master_slave_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate_matching) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(rate_matching)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).link_mode_masks) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ethtool_link_settings),
            "::",
            stringify!(link_mode_masks)
        )
    );
}
